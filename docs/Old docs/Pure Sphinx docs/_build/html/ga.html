<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Geometric Algebra &mdash; GA 3.0 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '3.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="GA 3.0 documentation" href="index.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="GA.html">GA 3.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <script type="text/javascript" >
    MathJax.Hub.Config({
        TeX: { equationNumbers: { autoNumber: "AMS" } }
    });
</script><div class="section" id="geometric-algebra">
<h1>Geometric Algebra<a class="headerlink" href="#geometric-algebra" title="Permalink to this headline">¶</a></h1>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Author:</th><td class="field-body">Alan Bromborsky</td>
</tr>
</tbody>
</table>
<div class="topic">
<p class="topic-title first">Abstract</p>
<p>This document describes the implementation, installation and use of a
geometric algebra module written in
python that utilizes the sympy symbolic algebra library.  The python
module ga has been developed for coordinate free calculations using
the operations (geometric, outer, and inner products etc.) of geometric algebra.
The operations can be defined using a completely arbitrary metric defined
by the inner products of a set of arbitrary vectors or the metric can be
restricted to enforce orthogonality and signature constraints on the set of
vectors.  Additionally, a metric that is a function of a coordinate set can
be defined so that a geometric algebra over a manifold can be implemented.
Geometric algebras over submanifolds of the base manifold are also supported as
well as linear multivector differential operators and linear transformations.
In addition the module includes the geometric, outer (curl) and inner
(div) derivatives. Tensors are included in the module as multilinear
functions of vectors with contraction and covariant differentiation
defined without the need of component indices.  For latex output a
latex distribution must be installed.  A more detail description of the
module and the mathematics behind it is at <a class="reference external" href="../../../LaTeX_docs/GA.pdf#page=13">GA[pg 12]</a>.</p>
</div>
<span class="target" id="module-sympy.galgebra.ga"></span><div class="section" id="what-is-geometric-algebra">
<h2>What is Geometric Algebra?<a class="headerlink" href="#what-is-geometric-algebra" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><div class="math">
\[\begin{split}\newcommand{\bm}[1]{\boldsymbol{#1}}
\newcommand{\bfrac}[2]{\displaystyle\frac{#1}{#2}}
\newcommand{\lp}{\left (}
\newcommand{\rp}{\right )}
\newcommand{\half}{\frac{1}{2}}
\newcommand{\llt}{\left &lt;}
\newcommand{\rgt}{\right &gt;}
\newcommand{\abs}[1]{\left |{#1}\right |}
\newcommand{\pdiff}[2]{\bfrac{\partial {#1}}{\partial {#2}}}
\newcommand{\pdifftwo}[3]{\bfrac{\partial^{2} {#1}}{\partial {#2}\partial {#3}}}
\newcommand{\lbrc}{\left \{}
\newcommand{\rbrc}{\right \}}
\newcommand{\set}[1]{\lbrc {#1} \rbrc}
\newcommand{\W}{\wedge}
\newcommand{\R}{\dagger}
\newcommand{\lbrk}{\left [}
\newcommand{\rbrk}{\right ]}
\newcommand{\com}[1]{\lbrk {#1} \rbrk}
\newcommand{\proj}[2]{\llt {#1} \rgt_{#2}}
\newcommand{\braces}[1]{\left \{ {#1} \right \}}
\newcommand{\grade}[1]{\left &lt; {#1} \right &gt;}
\newcommand{\f}[2]{{#1}\lp {#2} \rp}
\newcommand{\paren}[1]{\lp {#1} \rp}
\newcommand{\eval}[2]{\left . {#1} \right |_{#2}}
\newcommand{\prm}[1]{{#1}'}
\newcommand{\ddt}[1]{\bfrac{d{#1}}{dt}}
\newcommand{\deriv}[3]{\bfrac{d^{#3}#1}{d{#2}^{#3}}}
\newcommand{\be}{\begin{equation}}
\newcommand{\ee}{\end{equation}}
\newcommand{\eb}{\bm{e}}
\newcommand{\ehb}{\bm{\hat{e}}}
\newcommand{\Tn}[2]{\f{\mathcal{T}_{#2}}{#1}}
\newcommand{\tr}{\mbox{tr}}
\newcommand{\T}[1]{\texttt{#1}}
\newcommand{\grd}{\bm{\nabla}}\end{split}\]</div>
<p>Geometric algebra is the Clifford algebra of a real finite dimensional vector
space or the algebra that results when the vector space
is extended with a product of vectors (geometric product) that is associative,
left and right distributive, and yields a real number for the square (geometric
product) of any vector <a class="reference internal" href="#hestenes" id="id1">[Hestenes]</a>, <a class="reference internal" href="#doran" id="id2">[Doran]</a>.  The elements of the geometric
algebra are called multivectors and consist of the linear combination of
scalars, vectors, and the geometric product of two or more vectors. The
additional axioms for the geometric algebra are that for any vectors <span class="math">\(a\)</span>,
<span class="math">\(b\)</span>, and <span class="math">\(c\)</span> in the base vector space (<a class="reference internal" href="#doran" id="id3">[Doran]</a>,p85):</p>
<div class="math">
\[\begin{equation*}
    \begin{array}{c}
    a\left ( bc \right ) = \left ( ab \right ) c \\
    a\left ( b+c \right ) = ab+ac \\
    \left ( a + b \right ) c = ac+bc \\
    aa = a^{2} \in \Re
    \end{array}
\end{equation*}\]</div><p>The dot product of two vectors is defined by (<a class="reference internal" href="#doran" id="id4">[Doran]</a>,p86)</p>
<div class="math">
\[\begin{equation}
   a\cdot b \equiv (ab+ba)/2
\end{equation}\]</div><p>Then consider</p>
<div class="math">
\[\begin{align}
   c &= a+b \\
   c^{2} &= (a+b)^{2} \\
   c^{2} &= a^{2}+ab+ba+b^{2} \\
   a\cdot b &= (c^{2}-a^{2}-b^{2})/2 \in \Re
\end{align}\]</div><p>Thus <span class="math">\(a\cdot b\)</span>  is real.  The objects generated from linear combinations
of the geometric products of vectors are called multivectors.  If a basis for
the underlying vector space is the set of vectors formed from <span class="math">\(\boldsymbol{e}_{1},\dots,\boldsymbol{e}_{n}\)</span> (we use
boldface <span class="math">\(\boldsymbol{e}\)</span>&#8216;s to denote basis vectors)
a complete basis for the geometric algebra is given by the scalar <span class="math">\(1\)</span>, the vectors <span class="math">\(\boldsymbol{e}_{1},\dots,\boldsymbol{e}_{n}\)</span>
and all geometric products of basis vectors</p>
<div class="math">
\[\begin{equation}
    \boldsymbol{e}_{i_{1}}\boldsymbol{e}_{i_{2}}\dots \boldsymbol{e}_{i_{r}} \mbox{ where } 0\le r \le n,\;0 \le i_{j}
          \le n \mbox{ and } i_{1}\lt i_{2}\lt \dots\lt i_{r}
\end{equation}\]</div><p>Each base of the complete basis is represented by a noncommutative symbol (except for the scalar 1)
with name <span class="math">\(\boldsymbol{e}_{i_{1}}\dots \boldsymbol{e}_{i_{r}}\)</span> so that the general multivector <span class="math">\(\boldsymbol{A}\)</span> is represented by
(<span class="math">\(A\)</span> is the scalar part of the multivector and the <span class="math">\(A^{i_{1},\dots,i_{r}}\)</span> are scalars)</p>
<div class="math">
\[\begin{equation}
    \boldsymbol{A} = A + \sum_{r=1}^{n}\sum_{i_{1},\dots,i_{r}}^{0\le i_{j}\lt i_{j+1} \le n}
    A^{i_{1},\dots,i_{r}}\boldsymbol{e}_{i_{1}}\boldsymbol{e}_{i_{2}}\dots \boldsymbol{e}_{i_{r}}
\end{equation}\]</div><p>The critical operation in setting up the geometric algebra is reducing
the geometric product of any two bases to a linear combination of bases so that
we can calculate a multiplication table for the bases.  Since the geometric
product is associative we can use the operation (by definition for two vectors <span class="math">\(a\cdot b \equiv (ab+ba)/2\)</span>  which is a scalar)</p>
<div class="math">
\[ \begin{equation}\label{reduce}
    \boldsymbol{e}_{i_{j+1}}\boldsymbol{e}_{i_{j}} = 2\boldsymbol{e}_{i_{j+1}}\cdot \boldsymbol{e}_{i_{j}} - \boldsymbol{e}_{i_{j}}\boldsymbol{e}_{i_{j+1}}
 \end{equation}\]</div><p>These processes are repeated untill every basis list in <span class="math">\(\boldsymbol{A}\)</span> is in normal
(ascending) order with no repeated elements. As an example consider the
following</p>
<div class="math">
\[ \begin{align*}
    \boldsymbol{e}_{3}\boldsymbol{e}_{2}\boldsymbol{e}_{1} &= (2(\boldsymbol{e}_{2}\cdot \boldsymbol{e}_{3}) - \boldsymbol{e}_{2}\boldsymbol{e}_{3})\boldsymbol{e}_{1} \\
                    &= 2\left ( \boldsymbol{e}_{2}\cdot \boldsymbol{e}_{3}\right )\boldsymbol{e}_{1} -
                       \boldsymbol{e}_{2}\boldsymbol{e}_{3}\boldsymbol{e}_{1} \\
                    &= 2\left ( \boldsymbol{e}_{2}\cdot \boldsymbol{e}_{3}\right )\boldsymbol{e}_{1} -
                      \boldsymbol{e}_{2}\left ( 2\left ( \boldsymbol{e}_{1}\cdot \boldsymbol{e}_{3}\right ) -
                      \boldsymbol{e}_{1}\boldsymbol{e}_{3}\right ) \\
                    &= 2\left ( \left ( \boldsymbol{e}_{2}\cdot \boldsymbol{e}_{3}\right )\boldsymbol{e}_{1} -
                       \left ( \boldsymbol{e}_{1}\cdot \boldsymbol{e}_{3}\right )\boldsymbol{e}_{2}\right )+\boldsymbol{e}_{2}\boldsymbol{e}_{1}\boldsymbol{e}_{3} \\
                    &= 2\left ( \left ( {\boldsymbol{e}_{2}\cdot \boldsymbol{e}_{3}}\right )\boldsymbol{e}_{1} -
                    \left ( {\boldsymbol{e}_{1}\cdot \boldsymbol{e}_{3}}\right )\boldsymbol{e}_{2}+
                       \left ( \boldsymbol{e}_{1}\cdot \boldsymbol{e}_{2}\right )\boldsymbol{e}_{3}\right )-\boldsymbol{e}_{1}\boldsymbol{e}_{2}\boldsymbol{e}_{3}
 \end{align*}\]</div><p>which results from repeated application of eq. (<span class="math">\(\ref{reduce}\)</span>).  If the product of basis vectors contains repeated factors
eq. (<span class="math">\(\ref{reduce}\)</span>) can be used to bring the repeated factors next to one another so that if <span class="math">\(\boldsymbol{e}_{i_{j}} = \boldsymbol{e}_{i_{j+1}}\)</span>
then <span class="math">\(\boldsymbol{e}_{i_{j}}\boldsymbol{e}_{i_{j+1}} = \boldsymbol{e}_{i_{j}}\cdot \boldsymbol{e}_{i_{j+1}}\)</span> which is a scalar that commutes with all the terms in the product
and can be brought to the front of the product.  Since every repeated pair of vectors in a geometric product of <span class="math">\(r\)</span> factors
reduces the number of noncommutative factors in the product by <span class="math">\(r-2\)</span>. The number of bases in the multivector algebra is <span class="math">\(2^{n}\)</span>
and the number containing <span class="math">\(r\)</span> factors is <span class="math">\({n\choose r}\)</span> which is the number of combinations or <span class="math">\(n\)</span> things
taken <span class="math">\(r\)</span> at a time (binominal coefficient).</p>
<p>The other construction required for formulating the geometric algebra is the outer or wedge product (symbol <span class="math">\(\wedge\)</span>) of <span class="math">\(r\)</span>
vectors denoted by <span class="math">\(a_{1}\wedge\dots\wedge a_{r}\)</span>.  The wedge product of <span class="math">\(r\)</span> vectors is called an <span class="math">\(r\)</span>-blade and is defined
by (<a class="reference internal" href="#doran" id="id5">[Doran]</a>,p86)</p>
<div class="math">
\[ \begin{equation}
    a_{1}\wedge\dots\wedge a_{r} \equiv \sum_{i_{j_{1}}\dots i_{j_{r}}} \epsilon^{i_{j_{1}}\dots i_{j_{r}}}a_{i_{j_{1}}}\dots a_{i_{j_{1}}}
 \end{equation}\]</div><p>where <span class="math">\(\epsilon^{i_{j_{1}}\dots i_{j_{r}}}\)</span> is the contravariant permutation symbol which is <span class="math">\(+1\)</span> for an even permutation of the
superscripts, <span class="math">\(0\)</span> if any superscripts are repeated, and <span class="math">\(-1\)</span> for an odd permutation of the superscripts. From the definition
<span class="math">\(a_{1}\wedge\dots\wedge a_{r}\)</span> is antisymmetric in all its arguments and the following relation for the wedge product of a vector <span class="math">\(a\)</span> and an
<span class="math">\(r\)</span>-blade <span class="math">\(\boldsymbol{B}_{r}\)</span> can be derived</p>
<div class="math">
\[ \begin{equation}\label{wedge}
    a\wedge \boldsymbol{B}_{r} = (a\boldsymbol{B}_{r}+(-1)^{r}\boldsymbol{B}_{r}a)/2
 \end{equation}\]</div><p>Using eq. (<span class="math">\(\ref{wedge}\)</span>) one can represent the wedge product of all the basis vectors
in terms of the geometric product of all the basis vectors so that one can solve (the system
of equations is lower diagonal) for the geometric product of all the basis vectors in terms of
the wedge product of all the basis vectors.  Thus a general multivector <span class="math">\(\boldsymbol{B}\)</span> can be
represented as a linear combination of a scalar and the basis blades.</p>
<div class="math">
\[ \begin{equation}
    \boldsymbol{B} = B + \sum_{r=1}^{n}\sum_{i_{1},\dots,i_{r},\;\forall\; 0\le i_{j} \le n} B^{i_{1},\dots,i_{r}}\boldsymbol{e}_{i_{1}}\wedge \boldsymbol{e}_{i_{2}}\wedge\dots\wedge \boldsymbol{e}_{r}
 \end{equation}\]</div><p>Using the blades <span class="math">\(\boldsymbol{e}_{i_{1}}\wedge \boldsymbol{e}_{i_{2}}\wedge\dots\wedge \boldsymbol{e}_{r}\)</span> creates a graded
algebra where <span class="math">\(r\)</span> is the grade of the basis blades.  The grade-<span class="math">\(r\)</span>
part of <span class="math">\(\boldsymbol{B}\)</span> is the linear combination of all terms with
grade <span class="math">\(r\)</span> basis blades. The scalar part of <span class="math">\(\boldsymbol{B}\)</span> is defined to
be grade-<span class="math">\(0\)</span>.  Now that the blade expansion of <span class="math">\(\boldsymbol{B}\)</span> is defined
we can also define the grade projection operator <span class="math">\(\left &lt; \boldsymbol{B}\right &gt;_{r}\)</span> by</p>
<div class="math">
\[ \begin{equation}
    \left < \boldsymbol{B}\right >_{r} = \sum_{i_{1},\dots,i_{r},\;\forall\; 0\le i_{j} \le n} B^{i_{1},\dots,i_{r}}\boldsymbol{e}_{i_{1}}\wedge \boldsymbol{e}_{i_{2}}\wedge\dots\wedge \boldsymbol{e}_{r}
 \end{equation}\]</div><p>and</p>
<div class="math">
\[ \begin{equation}
    \left < \boldsymbol{B}\right >_{} \equiv \left < \boldsymbol{B}\right >_{0} = B
 \end{equation}\]</div><p>Then if <span class="math">\(\boldsymbol{A}_{r}\)</span> is an <span class="math">\(r\)</span>-grade multivector and <span class="math">\(\boldsymbol{B}_{s}\)</span> is an <span class="math">\(s\)</span>-grade multivector we have</p>
<div class="math">
\[ \begin{equation}
    \boldsymbol{A}_{r}\boldsymbol{B}_{s} = \left < \boldsymbol{A}_{r}\boldsymbol{B}_{s}\right >_{\left | {r-s}\right |}+
                           \left < \boldsymbol{A}_{r}\boldsymbol{B}_{s}\right >_{\left | {r-s}+2\right |}+\cdots
                           \left < \boldsymbol{A}_{r}\boldsymbol{B}_{s}\right >_{r+s}
 \end{equation}\]</div><p>and define (<a class="reference internal" href="#hestenes" id="id6">[Hestenes]</a>,p6)</p>
<div class="math">
\[ \begin{align}
    \boldsymbol{A}_{r}\wedge\boldsymbol{B}_{s} &\equiv \left < \boldsymbol{A}_{r}\boldsymbol{B}_{s}\right >_{r+s} \\
    \boldsymbol{A}_{r}\cdot\boldsymbol{B}_{s} &\equiv \left \{ \begin{array}{cc}
    r\mbox{ and }s \ne 0: & \left < \boldsymbol{A}_{r}\boldsymbol{B}_{s}\right >_{\left | {r-s}\right |}  \\
    r\mbox{ or }s = 0: & 0 \end{array} \right \}
 \end{align}\]</div><p>where <span class="math">\(\boldsymbol{A}_{r}\cdot\boldsymbol{B}_{s}\)</span> is called the dot or inner product of
two pure grade multivectors.  For the case of two non-pure grade multivectors</p>
<div class="math">
\[ \begin{align}
    \boldsymbol{A}\wedge\boldsymbol{B} &= \sum_{r,s}\left < \boldsymbol{A}\right >_{r}\wedge\left < \boldsymbol{B}\right >_{{s}} \\
    \boldsymbol{A}\cdot\boldsymbol{B} &= \sum_{r,s\ne 0}\left < \boldsymbol{A}\right >_{r}\cdot\left < \boldsymbol{B}\right >_{{s}}
 \end{align}\]</div><p>Two other products, the right (<span class="math">\(\rfloor\)</span>) and left (<span class="math">\(\lfloor\)</span>) contractions, are defined by</p>
<div class="math">
\[ \begin{align}
    \boldsymbol{A}\lfloor\boldsymbol{B} &\equiv \sum_{r,s}\left \{\begin{array}{cc} \left < \boldsymbol{A}_r\boldsymbol{B}_{s}\right >_{r-s} & r \ge s \\
                                                0                                               & r < s \end{array}\right \}  \\
    \boldsymbol{A}\rfloor\boldsymbol{B} &\equiv \sum_{r,s}\left \{\begin{array}{cc} \left < \boldsymbol{A}_{r}\boldsymbol{B}_{s}\right >_{s-r} & s \ge r \\
                                                0                                               & s < r\end{array}\right \}
 \end{align}\]</div><p>A final operation for multivectors is the reverse.  If a multivector <span class="math">\(\boldsymbol{A}\)</span> is the geometric product of <span class="math">\(r\)</span> vectors (versor)
so that <span class="math">\(\boldsymbol{A} = a_{1}\dots a_{r}\)</span> the reverse is defined by</p>
<div class="math">
\[ \begin{align}
    \boldsymbol{A}^{\dagger} \equiv a_{r}\dots a_{1}
 \end{align}\]</div><p>where for a general multivector we have (the the sum of the reverse of versors)</p>
<div class="math">
\[ \begin{equation}
    \boldsymbol{A}^{\dagger} = A + \sum_{r=1}^{n}(-1)^{r(r-1)/2}\sum_{i_{1},\dots,i_{r},\;\forall\; 0\le i_{j} \le n} A^{i_{1},\dots,i_{r}}\boldsymbol{e}_{i_{1}}\wedge \boldsymbol{e}_{i_{2}}\wedge\dots\wedge \boldsymbol{e}_{r}
 \end{equation}\]</div><p>note that if <span class="math">\(\boldsymbol{A}\)</span> is a versor then <span class="math">\(\boldsymbol{A}\boldsymbol{A}^{\dagger}\in\Re\)</span> and if
<span class="math">\(\boldsymbol{AA}^{\dagger} \ne 0\)</span> then</p>
<div class="math">
\[ \begin{equation}
    \boldsymbol{A}^{-1} = \frac{\boldsymbol{A}^{\dagger}}{\boldsymbol{AA}^{\dagger}}.
 \end{equation}\]</div></div></blockquote>
</div>
<div class="section" id="representation-of-multivectors-in-sympy">
<h2>Representation of Multivectors in <em>sympy</em><a class="headerlink" href="#representation-of-multivectors-in-sympy" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The sympy python module offers a simple way of representing multivectors using linear
combinations of commutative expressions (expressions consisting only of commuting sympy objects)
and noncommutative symbols. We start by defining <span class="math">\(n\)</span> noncommutative sympy symbols as a basis for
the vector space</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">(</span><span class="n">e_1</span><span class="p">,</span><span class="o">...</span><span class="p">,</span><span class="n">e_n</span><span class="p">)</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;e_1,...,e_n&#39;</span><span class="p">,</span><span class="n">commutative</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
</pre></div>
</div>
<p>Several software packages for numerical geometric algebra calculations are
available from Doran-Lasenby group and the Dorst group. Symbolic packages for
Clifford algebra using orthongonal bases such as
<span class="math">\(\boldsymbol{e}_{i}\boldsymbol{e}_{j}+\boldsymbol{e}_{j}\boldsymbol{e}_{i} = 2\eta_{ij}\)</span>, where <span class="math">\(\eta_{ij}\)</span> is a numeric
array are available in Maple and Mathematica. The symbolic algebra module,
<em>ga</em>, developed for python does not depend on an orthogonal basis
representation, but rather is generated from a set of <span class="math">\(n\)</span> arbitrary
symbolic vectors <span class="math">\(\boldsymbol{e}_{1},\boldsymbol{e}_{2},\dots,\boldsymbol{e}_{n}\)</span> and a symbolic metric
tensor <span class="math">\(g_{ij} = \boldsymbol{e}_{i}\cdot \boldsymbol{e}_{j}\)</span> (the symbolic metric can be symbolic constants
or symbolic functions in the case of a manifold).</p>
<p>All scalar symbolic algebra is handled by the
python module sympy and the abstract basis vectors are encoded as
noncommuting sympy symbols.</p>
<p>The basic geometic algebra operations will be implemented in python by defining
a geometric algebra class, <em>Ga</em>, that performs all required geometric algebra an
calculus operations on sympy expressions of the form (Einstein summation convention)</p>
<div class="math">
\[  \begin{equation}
     F +\sum_{r=1}^{n}F^{i_{1}\dots i_{r}}\boldsymbol{e}_{i_{1}}\dots\boldsymbol{e}_{i_{r}}
  \end{equation}\]</div><p>where the <span class="math">\(F\)</span>&#8216;s are sympy symbolic constants or functions of the
coordinates and a multivector class, <em>Mv</em>, that wraps <em>Ga</em> and overloads the python operators to provide
all the needed multivector operations as shown in the table of multivector operations
where <em>A</em> and <em>B</em>  are any two multivectors (In the case of
<em>+</em>, <em>-</em>, <em>*</em>, <em>^</em>, <em>|</em>, <em>&lt;</em>, and <em>&gt;</em> the operation is also defined if <em>A</em> or
<em>B</em> is a sympy symbol or a sympy real number).</p>
<a class="reference internal image-reference" href="_images/mvops.png"><img alt="_images/mvops.png" class="align-center" src="_images/mvops.png" style="width: 350px;" /></a>
<p>Since <em>&lt;</em> and <em>&gt;</em> have no r-forms (in python for the <em>&lt;</em> and <em>&gt;</em> operators there are no <em>__rlt__()</em> and
<em>__rgt__()</em> member functions to overload)
we can only have mixed modes (scalars and multivectors) if the first operand is a multivector.</p>
<blockquote>
<div><p>Except for <em>&lt;</em> and <em>&gt;</em> all the multivector operators have r-forms so that as long as one of the
operands, left or right, is a multivector the other can be a multivector or a scalar (sympy symbol or integer).</p>
<p>Note that the operator order precedence is determined by python and is not
necessarily that used by geometric algebra. It is <strong>absolutely essential</strong> to
use parenthesis in multivector
expressions containing <em>^</em>, <em>|</em>, <em>&lt;</em>, and/or <em>&gt;</em>.  As an example let
<em>A</em> and <em>B</em> be any two multivectors. Then <em>A + A*B = A +(A*B)</em>, but
<em>A+A^B = (2*A)^B</em> since in python the <em>^</em> operator has a lower precedence
than the <em>+</em> operator.  In geometric algebra the outer and inner products and
the left and right contractions have a higher precedence than the geometric
product and the geometric product has a higher precedence than addition and
subtraction.  In python the <em>^</em>, <em>|</em>, <em>&gt;</em>, and <em>&lt;</em> all have a lower
precedence than <em>+</em> and <em>-</em> while <em>*</em> has a higher precedence than
<em>+</em> and <em>-</em>.</p>
</div></blockquote>
<p>For those users who wish to define a default operator precedence the functions
<em>def_prec()</em> and <em>GAeval()</em> are available in the module printer.</p>
<blockquote>
<div><p><em>def_prec(gd,op_ord=&#8217;&lt;&gt;|,^,*&#8217;)</em></p>
<blockquote>
<div>Define the precedence of the multivector operations.  The function
<em>def_prec()</em> must be called from the main program and the
first argument <em>gd</em> must be set to <em>globals()</em>.  The second argument
<em>op_ord</em> determines the operator precedence for expressions input to
the function <em>GAeval()</em>. The default value of <em>op_ord</em> is <em>&lt;&gt;|,^,*</em>.
For the default value the <em>&lt;</em>, <em>&gt;</em>, and <em>|</em> operations have equal
precedence followed by <em>^</em>, and <em>^</em> is followed by <em>*</em>.</div></blockquote>
<p><em>GAeval(s,pstr=False)</em></p>
<blockquote>
<div><p>The function <em>GAeval()</em> returns a multivector expression defined by the
string <em>s</em> where the operations in the string are parsed according to
the precedences defined by <em>define_precedence()</em>. <em>pstr</em> is a flag
to print the input and output of <em>GAeval()</em> for debugging purposes.
<em>GAeval()</em> works by adding parenthesis to the input string <em>s</em> with the
precedence defined by <em>op_ord=&#8217;&lt;&gt;|,^,*&#8217;</em>.  Then the parsed string is
converted to a sympy expression using the python <em>eval()</em> function.
For example consider where <em>X</em>, <em>Y</em>, <em>Z</em>, and <em>W</em> are multivectors</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">def_prec</span><span class="p">(</span><span class="nb">globals</span><span class="p">())</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">GAeval</span><span class="p">(</span><span class="s">&#39;X|Y^Z*W&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>The sympy variable <em>V</em> would evaluate to <em>((X|Y)^Z)*W</em>.</p>
</div></blockquote>
</div></blockquote>
<div class="section" id="vector-basis-and-metric">
<span id="vbm"></span><h3>Vector Basis and Metric<a class="headerlink" href="#vector-basis-and-metric" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>The two structures that define the <em>metric</em> class (inherited by the
geometric algebra class) are the
symbolic basis vectors and the symbolic metric.  The symbolic basis
vectors are input as a string with the symbol name separated by spaces.  For
example if we are calculating the geometric algebra of a system with three
vectors that we wish to denote as <em>a0</em>, <em>a1</em>, and <em>a2</em> we would define the
string variable:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">basis</span> <span class="o">=</span> <span class="s">&#39;a0 a1 a2&#39;</span>
</pre></div>
</div>
<p>that would be input into the function which instantiates the geometric
algebra.  The next step would be
to define the symbolic metric for the geometric algebra of the basis we
have defined. The default metric is the most general and is the matrix of
the following symbols</p>
<blockquote>
<div><div class="math">
\[\begin{equation}\label{metric}
g = \left [
\begin{array}{ccc}
  (a0.a0) & (a0.a1)  & (a0.a2) \\
  (a0.a1) & (a1.a1)  & (a1.a2) \\
  (a0.a2) & (a1.a2) & (a2.a2)
\end{array}
\right ]
\end{equation}\]</div></div></blockquote>
<p>where each of the <span class="math">\(g_{ij}\)</span> is a symbol representing all of the dot
products of the basis vectors. Note that the symbols are named so that
<span class="math">\(g_{ij} = g_{ji}\)</span> since for the sympy symbols <span class="math">\((a0.a1) \ne (a1.a0)\)</span>.
Note that the strings shown in eq <span class="math">\(\ref{metric}\)</span> are only used when the values
of <span class="math">\(g_{ij}\)</span> are output (printed).   In the <em>ga</em> module (library)
the <span class="math">\(g_{ij}\)</span> symbols are stored in a member of the geometric algebra
instance so that if  <em>o3d</em> is a geometric algebra then <em>o3d.g</em> is
the metric tensor (<span class="math">\(g_{ij} =\)</span> <em>o3d.g[i,j]</em>) for that algebra.</p>
<p>The default definition of <span class="math">\(g\)</span> can be overwritten by specifying a string
that will define <span class="math">\(g\)</span>. As an example consider a symbolic representation
for conformal geometry. Define a basis</p>
<blockquote>
<div><div class="highlight-python"><div class="highlight"><pre><span class="n">basis</span> <span class="o">=</span> <span class="s">&#39;a0 a1 a2 n nbar&#39;</span>
</pre></div>
</div>
</div></blockquote>
<p>and a metric</p>
<blockquote>
<div><div class="highlight-python"><div class="highlight"><pre><span class="n">g</span> <span class="o">=</span> <span class="s">&#39;# # # 0 0, # # # 0 0, # # # 0 0, 0 0 0 0 2, 0 0 0 2 0&#39;</span>
</pre></div>
</div>
</div></blockquote>
<p>then calling <em>cf3d = Ga(basis,g=g)</em> would initialize the metric tensor</p>
<div class="math">
\[\begin{equation}
g = \left [
\begin{array}{ccccc}
  (a0.a0) & (a0.a1)  & (a0.a2) & 0 & 0\\
  (a0.a1) & (a1.a1)  & (a1.a2) & 0 & 0\\
  (a0.a2) & (a1.a2)  & (a2.a2) & 0 & 0 \\
  0 & 0 & 0 & 0 & 2 \\
  0 & 0 & 0 & 2 & 0
\end{array}
\right [
\end{equation}\]</div><p>for the  <em>cf3d</em> (conformal 3-d) geometric algebra.</p>
<p>Here we have specified that <em>n</em> and <em>nbar</em> are orthogonal to all the
<em>a</em>&#8216;s, <em>(n.n) = (nbar.nbar) = 0</em>, and <em>(n.nbar) = 2</em>. Using
<em>#</em> in the metric definition string just tells the program to use the
default symbol for that value.</p>
<p>When <em>Ga</em> is called multivector representations of the basis local to
the program are instantiated.  For the case of an orthogonal 3-d vector
space that means the
symbolic vectors named <em>a0</em>, <em>a1</em>, and <em>a2</em> are created. We can
instantiate the geometric algebra and obtain the basis vectors with -</p>
<blockquote>
<div><div class="highlight-python"><div class="highlight"><pre><span class="n">o3d</span> <span class="o">=</span> <span class="n">Ga</span><span class="p">(</span><span class="s">&#39;a_1 a_2 a_3&#39;</span><span class="p">,</span><span class="n">g</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="p">(</span><span class="n">a_1</span><span class="p">,</span><span class="n">a_2</span><span class="p">,</span><span class="n">a_3</span><span class="p">)</span> <span class="o">=</span> <span class="n">o3d</span><span class="o">.</span><span class="n">mv</span><span class="p">()</span>
</pre></div>
</div>
</div></blockquote>
<p>or use the <em>Ga.build()</em> function -</p>
<blockquote>
<div><div class="highlight-python"><div class="highlight"><pre><span class="p">(</span><span class="n">o3d</span><span class="p">,</span><span class="n">a_1</span><span class="p">,</span><span class="n">a_2</span><span class="p">,</span><span class="n">a_3</span><span class="p">)</span> <span class="o">=</span> <span class="n">Ga</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="s">&#39;a_1 a_2 a_3&#39;</span><span class="p">,</span><span class="n">g</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</div></blockquote>
<p>Note that the python variable name for a basis vector does not have to
correspond to the name give in <em>Ga()</em> or <em>Ga.build()</em>, one may wish to use a
shortened python variable name to reduce programming (typing) errors, for
example one could use -</p>
<blockquote>
<div><div class="highlight-python"><div class="highlight"><pre><span class="p">(</span><span class="n">o3d</span><span class="p">,</span><span class="n">a1</span><span class="p">,</span><span class="n">a2</span><span class="p">,</span><span class="n">a3</span><span class="p">)</span> <span class="o">=</span> <span class="n">Ga</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="s">&#39;a_1 a_2 a_3&#39;</span><span class="p">,</span><span class="n">g</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</div></blockquote>
<p>or</p>
<blockquote>
<div><div class="highlight-python"><div class="highlight"><pre><span class="p">(</span><span class="n">st4d</span><span class="p">,</span><span class="n">g0</span><span class="p">,</span><span class="n">g1</span><span class="p">,</span><span class="n">g2</span><span class="p">,</span><span class="n">g3</span><span class="p">)</span> <span class="o">=</span> <span class="n">Ga</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="s">&#39;gamma_0 gamma_1 gamma_2 gamma_3&#39;</span><span class="p">,</span><span class="n">g</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</div></blockquote>
<p>for Minkowski spacetime.</p>
<p>If the latex printer is used <em>e1</em> would print as <span class="math">\(\boldsymbol{e_{1}}\)</span>
and <em>g1</em> as <span class="math">\(\boldsymbol{\gamma_{1}}\)</span>.</p>
<blockquote>
<div><p>Additionally <em>Ga()</em> and <em>Ga.build()</em> has simpified options for naming a set of basis vectors and for
inputing an othogonal basis.</p>
<p>If one wishes to name the basis vectors <span class="math">\(\boldsymbol{e}_{x}\)</span>, <span class="math">\(\boldsymbol{e}_{y}\)</span>, and
<span class="math">\(\boldsymbol{e}_{z}\)</span> then set <em>basis=&#8217;e*x|y|z&#8217;</em> or to name <span class="math">\(\boldsymbol{\gamma}_{t}\)</span>,
<span class="math">\(\boldsymbol{\gamma}_{x}\)</span>, <span class="math">\(\boldsymbol{\gamma}_{y}\)</span>, and <span class="math">\(\boldsymbol{\gamma}_{z}\)</span> then set
<em>basis=&#8217;gamma*t|x|y|z&#8217;</em>.
For the case of an othogonal basis if the signature of the
vector space is <span class="math">\((1,1,1)\)</span> (Euclidian 3-space) set <em>g=[1,1,1]</em> or if it
is <span class="math">\((1,-1,-1,-1)\)</span> (Minkowsi 4-space) set <em>g=[1,-1,-1,-1]</em>. If <em>g</em> is a
function of position then <em>g</em> can be entered as a sympy matrix with sympy
functions as the entries of the matrix or as a list of functions for the
case of a orthogonal metric.  In the case of spherical coordinates we have
<em>g=[1,r**2,r**2*sin(th)**2]</em>.</p>
</div></blockquote>
</div></blockquote>
</div>
<div class="section" id="representation-and-reduction-of-multivector-bases">
<h3>Representation and Reduction of Multivector Bases<a class="headerlink" href="#representation-and-reduction-of-multivector-bases" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>In our symbolic geometric algebra all multivectors
can be obtained from the symbolic basis vectors we have input, via the
different operations available to geometric algebra. The first problem we have
is representing the general multivector in terms terms of the basis vectors.  To
do this we form the ordered geometric products of the basis vectors and develop
an internal representation of these products in terms of python classes.  The
ordered geometric products are all multivectors of the form
<span class="math">\(a_{i_{1}}a_{i_{2}}\dots a_{i_{r}}\)</span> where <span class="math">\(i_{1}&lt;i_{2}&lt;\dots &lt;i_{r}\)</span>
and <span class="math">\(r \le n\)</span>. We call these multivectors bases and represent them
internally with noncommutative symbols so for example <span class="math">\(a_{1}a_{2}a_{3}\)</span>
is represented by</p>
<blockquote>
<div></div></blockquote>
<p>In the simplest case of two basis vectors <em>a_1</em> and <em>a_2</em> we have a list of
bases</p>
<blockquote>
<div></div></blockquote>
<p>For the case of the basis blades we have</p>
<blockquote>
<div></div></blockquote>
<p>The index tupels for the bases of each pseudo grade and each grade for the case of dimension 3 is</p>
<blockquote>
<div></div></blockquote>
<p>Then the noncommutative symbol representing each base is constructed from each index tuple.
For example for <em>self.indexes[1][1]</em> the symbol is <em>Symbol(&#8216;a_1*a_3&#8217;,commutative=False)</em>.</p>
</div></blockquote>
</div>
<div class="section" id="base-representation-of-multivectors">
<h3>Base Representation of Multivectors<a class="headerlink" href="#base-representation-of-multivectors" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>In terms of the bases defined as noncommutative <em>sympy</em> symbols the general multivector
is a linear combination (scalar <em>sympy</em> coefficients) of bases so that for the case
of two bases the most general multivector is given by -</p>
<blockquote>
<div><em>A = A_0+A__1*self.bases[1][0]+A__2*self.bases[1][1]+A__12*self.bases[2][0]</em></div></blockquote>
<p>If we have another multivector <em>B</em> to multiply with <em>A</em> we can calculate the product in
terms of a linear combination of bases if we have a multiplication table for the bases.</p>
</div></blockquote>
</div>
<div class="section" id="blade-representation-of-multivectors">
<h3>Blade Representation of Multivectors<a class="headerlink" href="#blade-representation-of-multivectors" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>Since we can now calculate the symbolic geometric product of any two
multivectors we can also calculate the blades corresponding to the product of
the symbolic basis vectors using the formula</p>
<blockquote>
<div><div class="math">
\[\begin{equation}
  A_{r}\wedge b = \frac{1}{2}\left ( A_{r}b-\left ( -1 \right )^{r}bA_{r} \right ),
\end{equation}\]</div></div></blockquote>
<p>where <span class="math">\(A_{r}\)</span> is a multivector of grade <span class="math">\(r\)</span> and <span class="math">\(b\)</span> is a
vector.  For our example basis the result is the table</p>
<blockquote>
<div><div class="highlight-python"><div class="highlight"><pre><span class="mi">1</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">a0</span> <span class="o">=</span> <span class="n">a0</span>
<span class="n">a1</span> <span class="o">=</span> <span class="n">a1</span>
<span class="n">a2</span> <span class="o">=</span> <span class="n">a2</span>
<span class="n">a0</span><span class="o">^</span><span class="n">a1</span> <span class="o">=</span> <span class="p">{</span><span class="o">-</span><span class="p">(</span><span class="n">a0</span><span class="o">.</span><span class="n">a1</span><span class="p">)}</span><span class="mi">1</span><span class="o">+</span><span class="n">a0a1</span>
<span class="n">a0</span><span class="o">^</span><span class="n">a2</span> <span class="o">=</span> <span class="p">{</span><span class="o">-</span><span class="p">(</span><span class="n">a0</span><span class="o">.</span><span class="n">a2</span><span class="p">)}</span><span class="mi">1</span><span class="o">+</span><span class="n">a0a2</span>
<span class="n">a1</span><span class="o">^</span><span class="n">a2</span> <span class="o">=</span> <span class="p">{</span><span class="o">-</span><span class="p">(</span><span class="n">a1</span><span class="o">.</span><span class="n">a2</span><span class="p">)}</span><span class="mi">1</span><span class="o">+</span><span class="n">a1a2</span>
<span class="n">a0</span><span class="o">^</span><span class="n">a1</span><span class="o">^</span><span class="n">a2</span> <span class="o">=</span> <span class="p">{</span><span class="o">-</span><span class="p">(</span><span class="n">a1</span><span class="o">.</span><span class="n">a2</span><span class="p">)}</span><span class="n">a0</span><span class="o">+</span><span class="p">{(</span><span class="n">a0</span><span class="o">.</span><span class="n">a2</span><span class="p">)}</span><span class="n">a1</span><span class="o">+</span><span class="p">{</span><span class="o">-</span><span class="p">(</span><span class="n">a0</span><span class="o">.</span><span class="n">a1</span><span class="p">)}</span><span class="n">a2</span><span class="o">+</span><span class="n">a0a1a2</span>
</pre></div>
</div>
</div></blockquote>
<p>which gives the bases blades in terms of bases.</p>
<p>The important thing to notice about this expansion is that it is a
triagonal (lower triangular) system of equations so that using a simple back
substitution algorithm we can solve for the pseudo bases in terms of the blades
giving the table</p>
<blockquote>
<div><div class="highlight-python"><div class="highlight"><pre><span class="mi">1</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">a0</span> <span class="o">=</span> <span class="n">a0</span>
<span class="n">a1</span> <span class="o">=</span> <span class="n">a1</span>
<span class="n">a2</span> <span class="o">=</span> <span class="n">a2</span>
<span class="n">a0a1</span> <span class="o">=</span> <span class="p">{(</span><span class="n">a0</span><span class="o">.</span><span class="n">a1</span><span class="p">)}</span><span class="mi">1</span><span class="o">+</span><span class="n">a0</span><span class="o">^</span><span class="n">a1</span>
<span class="n">a0a2</span> <span class="o">=</span> <span class="p">{(</span><span class="n">a0</span><span class="o">.</span><span class="n">a2</span><span class="p">)}</span><span class="mi">1</span><span class="o">+</span><span class="n">a0</span><span class="o">^</span><span class="n">a2</span>
<span class="n">a1a2</span> <span class="o">=</span> <span class="p">{(</span><span class="n">a1</span><span class="o">.</span><span class="n">a2</span><span class="p">)}</span><span class="mi">1</span><span class="o">+</span><span class="n">a1</span><span class="o">^</span><span class="n">a2</span>
<span class="n">a0a1a2</span> <span class="o">=</span> <span class="p">{(</span><span class="n">a1</span><span class="o">.</span><span class="n">a2</span><span class="p">)}</span><span class="n">a0</span><span class="o">+</span><span class="p">{</span><span class="o">-</span><span class="p">(</span><span class="n">a0</span><span class="o">.</span><span class="n">a2</span><span class="p">)}</span><span class="n">a1</span><span class="o">+</span><span class="p">{(</span><span class="n">a0</span><span class="o">.</span><span class="n">a1</span><span class="p">)}</span><span class="n">a2</span><span class="o">+</span><span class="n">a0</span><span class="o">^</span><span class="n">a1</span><span class="o">^</span><span class="n">a2</span>
</pre></div>
</div>
</div></blockquote>
<p>of the bases in terms of the basis blades.</p>
<p>Using these tables and simple substitution we can convert from a base
multivector representation to a blade representation and vice versa.</p>
<p>Using the blade representation it becomes simple to program functions that will
calculate the grade projection, reverse, even, and odd multivector functions.</p>
<p>Note that in the multivector class <em>Mv</em> there is a class variable for each
instantiation, <em>self.is_blade_rep</em>, that is set to <em>False</em> for a base representation
and <em>True</em> for a blade representation.  One needs to keep track of which
representation is in use since various multivector operations require conversion
from one representation to the other.</p>
</div></blockquote>
</div>
</div>
<div class="section" id="outer-and-inner-products-left-and-right-contractions">
<h2>Outer and Inner Products, Left and Right Contractions<a class="headerlink" href="#outer-and-inner-products-left-and-right-contractions" title="Permalink to this headline">¶</a></h2>
<p>In geometric algebra any general multivector <span class="math">\(A\)</span> can be decomposed into
pure grade multivectors (a linear combination of blades of all the same order)
so that in a <span class="math">\(n\)</span>-dimensional vector space</p>
<div class="math">
\[\begin{equation}
A = \sum_{r = 0}^{n}A_{r}
\end{equation}\]</div><p>The geometric product of two pure grade multivectors <span class="math">\(A_{r}\)</span> and
<span class="math">\(B_{s}\)</span> has the form</p>
<div class="math">
\[\begin{equation}
A_{r}B_{s} = \left < {A_{r}B_{s}} \right >_{\left |{{r-s}}\right |}+\left < {A_{r}B_{s}} \right >_{\left |{{r-s}}\right |+2}+\cdots+\left < {A_{r}B_{s}} \right >_{r+s}
\end{equation}\]</div><p>where <span class="math">\(\left &lt; { } \right &gt;_{t}\)</span> projects the <span class="math">\(t\)</span> grade components of the
multivector argument.  The inner and outer products of <span class="math">\(A_{r}\)</span> and
<span class="math">\(B_{s}\)</span> are then defined to be</p>
<div class="math">
\[\begin{equation}
A_{r}\cdot B_{s} = \left < {A_{r}B_{s}} \right >_{\left |{{r-s}}\right |}
\end{equation}\]</div><div class="math">
\[\begin{equation}
A_{r}\wedge B_{s} = \left < {A_{r}B_{s}} \right >_{r+s}
\end{equation}\]</div><p>and</p>
<div class="math">
\[\begin{equation}
A\cdot B = \sum_{r,s > 0}A_{r}\cdot B_{s}
\end{equation}\]</div><div class="math">
\[\begin{equation}
A\wedge B = \sum_{r,s}A_{r}\wedge B_{s}
\end{equation}\]</div><p>Likewise the right (<span class="math">\(\lfloor\)</span>) and left (<span class="math">\(\rfloor\)</span>) contractions are defined as</p>
<div class="math">
\[\begin{equation}
A_{r}\lfloor B_{s} = \left \{ \begin{array}{cc}
   \left < {A_{r}B_{s}} \right >_{r-s} &  r \ge s \\
             0            &  r < s \end{array} \right \}
\end{equation}\]</div><div class="math">
\[\begin{equation}
A_{r}\rfloor B_{s} = \left \{ \begin{array}{cc}
   \left < {A_{r}B_{s}} \right >_{s-r} &  s \ge r \\
             0            &  s < r \end{array} \right \}
\end{equation}\]</div><p>and</p>
<div class="math">
\[\begin{equation}
A\lfloor B = \sum_{r,s}A_{r}\lfloor B_{s}
\end{equation}\]</div><div class="math">
\[\begin{equation}
A\rfloor B = \sum_{r,s}A_{r}\rfloor B_{s}
\end{equation}\]</div><div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">In the  <em>MV</em> class we have overloaded the <em>^</em> operator to represent the outer
product so that instead of calling the outer product function we can write <em>mv1^ mv2</em>.
Due to the precedence rules for python it is <strong>absolutely essential</strong> to enclose outer products
in parenthesis.</p>
</div>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">In the <em>MV</em> class we have overloaded the <em>|</em> operator for the inner product,
<em>&gt;</em> operator for the right contraction, and <em>&lt;</em> operator for the left contraction.
Instead of calling the inner product function we can write <em>mv1|mv2</em>, <em>mv1&gt;mv2</em>, or
<em>mv1&lt;mv2</em> respectively for the inner product, right contraction, or left contraction.
Again, due to the precedence rules for python it is <strong>absolutely essential</strong> to enclose inner
products and/or contractions in parenthesis.</p>
</div>
</div>
<div class="section" id="reverse-of-multivector">
<span id="reverse"></span><h2>Reverse of Multivector<a class="headerlink" href="#reverse-of-multivector" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>If <span class="math">\(A\)</span> is the geometric product of <span class="math">\(r\)</span> vectors</p>
<div class="math">
\[\begin{equation}
  A = a_{1}\dots a_{r}
\end{equation}\]</div><p>then the reverse of <span class="math">\(A\)</span> designated <span class="math">\(A^{\dagger}\)</span> is defined by</p>
<div class="math">
\[\begin{equation}
  A^{\dagger} \equiv a_{r}\dots a_{1}.
\end{equation}\]</div><p>The reverse is simply the product with the order of terms reversed.  The reverse
of a sum of products is defined as the sum of the reverses so that for a general
multivector A we have</p>
<div class="math">
\[\begin{equation}
  A^{\dagger} = \sum_{i=0}^{N} {\left < {A} \right >_{i}}^{\dagger}
\end{equation}\]</div><p>but</p>
<div class="math">
\[\begin{equation}
  {\left < {A} \right >_{i}}^{\dagger} = \left ( -1\right )^{\frac{i\left ( i-1\right )}{2}}\left < {A} \right >_{i}
\end{equation}\]</div><p>which is proved by expanding the blade bases in terms of orthogonal vectors and
showing that eq. <span class="math">\(\ref{eq_4}\)</span> holds for the geometric product of orthogonal
vectors.</p>
<p>The reverse is important in the theory of rotations in <span class="math">\(n\)</span>-dimensions.  If
<span class="math">\(R\)</span> is the product of an even number of vectors and <span class="math">\(RR^{\dagger} = 1\)</span>
then <span class="math">\(RaR^{\dagger}\)</span> is a composition of rotations of the vector <span class="math">\(a\)</span>.
If <span class="math">\(R\)</span> is the product of two vectors then the plane that <span class="math">\(R\)</span> defines
is the plane of the rotation.  That is to say that <span class="math">\(RaR^{\dagger}\)</span> rotates the
component of <span class="math">\(a\)</span> that is projected into the plane defined by <span class="math">\(a\)</span> and
<span class="math">\(b\)</span> where <span class="math">\(R=ab\)</span>.  <span class="math">\(R\)</span> may be written
<span class="math">\(R = e^{\frac{\theta}{2}U}\)</span>, where <span class="math">\(\theta\)</span> is the angle of rotation
and <span class="math">\(u\)</span> is a unit blade <span class="math">\(\left ( u^{2} = \pm 1\right )\)</span> that defines the
plane of rotation.</p>
</div></blockquote>
</div>
<div class="section" id="reciprocal-frames">
<span id="recframe"></span><h2>Reciprocal Frames<a class="headerlink" href="#reciprocal-frames" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>If we have <span class="math">\(M\)</span> linearly independent vectors (a frame),
<span class="math">\(a_{1},\dots,a_{M}\)</span>, then the reciprocal frame is
<span class="math">\(a^{1},\dots,a^{M}\)</span> where <span class="math">\(a_{i}\cdot a^{j} = \delta_{i}^{j}\)</span>,
<span class="math">\(\delta_{i}^{j}\)</span> is the Kronecker delta (zero if <span class="math">\(i \ne j\)</span> and one
if <span class="math">\(i = j\)</span>). The reciprocal frame is constructed as follows:</p>
<div class="math">
\[\begin{equation}
  E_{M} = a_{1}\wedge\dots\wedge a_{M}
\end{equation}\]</div><div class="math">
\[\begin{equation}
  E_{M}^{-1} = \frac{E_{M}}{E_{M}^{2}}
\end{equation}\]</div><p>Then</p>
<div class="math">
\[\begin{equation}
  a^{i} = \left ( -1\right )^{i-1}\left ( a_{1}\wedge\dots\wedge \breve{a}_{i} \wedge\dots\wedge a_{M}\right ) E_{M}^{-1}
\end{equation}\]</div><p>where <span class="math">\(\breve{a}_{i}\)</span> indicates that <span class="math">\(a_{i}\)</span> is to be deleted from
the product.  In the standard notation if a vector is denoted with a subscript
the reciprocal vector is denoted with a superscript. The set of reciprocal vectors
will be calculated if a coordinate set is given when a geometric algebra is instantiated since
they are required for geometric differentiation.</p>
</div></blockquote>
</div>
<div class="section" id="manifolds-and-submanifolds">
<span id="manifold"></span><h2>Manifolds and Submanifolds<a class="headerlink" href="#manifolds-and-submanifolds" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>A <span class="math">\(m\)</span>-dimensional vector manifold (By the manifold embedding theorem any <span class="math">\(m\)</span>-dimensional
manifold is isomorphic to a <span class="math">\(m\)</span>-dimensional vector manifold), <span class="math">\(\mathcal{M}\)</span>, is defined by a
coordinate tuple (tuples are indicated by the vector accent <span class="math">\(\vec{x}\)</span>)</p>
<div class="math">
\[  \begin{equation}
      \vec{x} = \left ( x^{1},\dots,x^{m} \right ),
  \end{equation}\]</div><p>and the differentiable mapping (<span class="math">\(U^{m}\)</span> is an <span class="math">\(m\)</span>-dimensional subset of <span class="math">\(\Re^{m}\)</span>)</p>
<div class="math">
\[  \begin{equation}
      \boldsymbol{e}^{\mathcal{M}}(\vec{x})\colon U^{m}\subseteq\Re^{m}\rightarrow \mathcal{V},
  \end{equation}\]</div><p>where <span class="math">\(\mathcal{V}\)</span> is a vector space with an inner product (<span class="math">\(\cdot\)</span>) and is of
<span class="math">\(\dim (\mathcal{V}) \ge m\)</span>.</p>
<p>Then a set of basis vectors for the tangent space of <span class="math">\(\mathcal{M}\)</span> at <span class="math">\(\vec{x}\)</span>,
<span class="math">\(\mathcal{T}_{\vec{x}}\left( \mathcal{M} \right )\)</span>, are</p>
<div class="math">
\[  \begin{equation}
      \boldsymbol{e}_{i}^{\mathcal{M}} = \partial_{x^{i}}\boldsymbol{e}^{\mathcal{M}}
  \end{equation}\]</div><p>and</p>
<div class="math">
\[  \begin{equation}
      g_{ij}^{\mathcal{M}}\left (\vec{x}\right ) = \boldsymbol{e}_{i}^{\mathcal{M}}\cdot \boldsymbol{e}_{j}^{\mathcal{M}}.
  \end{equation}\]</div><p>A <span class="math">\(n\)</span>-dimensional (<span class="math">\(n\le m\)</span>) submanifold <span class="math">\(\mathcal{N}\)</span> of <span class="math">\(\mathcal{M}\)</span> is defined by
a coordinate tuple</p>
<div class="math">
\[  \begin{equation}
      \vec{u} = \left (u^{1},\dots,u^{n} \right ),
  \end{equation}\]</div><p>and a differentiable mapping</p>
<div class="math">
\[  \begin{equation}\label{eq_79}
      \vec{x}(\vec{u})\colon U^{n}\subseteq\Re^{n}\rightarrow U^{m}\subseteq\Re^{m},
  \end{equation}\]</div><p>which induces a mapping</p>
<div class="math">
\[  \begin{equation}
      \boldsymbol{e}^{\mathcal{M}}\left (\vec{x}(\vec{u})\right )\colon U^{n}\subseteq\Re^{n}\rightarrow \mathcal{V}.
  \end{equation}\]</div><p>Then the basis vectors for the tangent space <span class="math">\(\mathcal{T}_{\vec{u}}\left( \mathcal{N} \right )\)</span> are
(using <span class="math">\(\boldsymbol{e}^{\mathcal{N}}(\vec{u}) = \boldsymbol{e}^{\mathcal{M}}(\vec{x}(\vec{u}))\)</span> and the chain rule)</p>
<div class="math">
\[  \begin{equation}
      \boldsymbol{e}_{i}^{\mathcal{N}}(\vec{u}) = \partial_{u^{i}}\boldsymbol{e}^{\mathcal{N}}(\vec{u})
                                  = \partial_{x^{j}}\boldsymbol{e}^{\mathcal{M}}(\vec{x})\partial_{u^{i}}x^{j}
                                  = \boldsymbol{e}_{j}^{\mathcal{M}}(\vec{x}(\vec{u}))\partial_{u^{i}}x^{j},
  \end{equation}\]</div><p>and</p>
<div class="math">
\[  \begin{equation}\label{eq_53}
      g_{ij}^{\mathcal{N}}(\vec{u}) = \partial_{u^{i}}{x^{k}}\partial_{u^{j}}{x^{l}}
                                              g_{kl}^{\mathcal{M}}\vec{x}(\vec{u}).
  \end{equation}\]</div><p>Going back to the base manifold, <span class="math">\(\mathcal{M}\)</span>, note that the mapping
<span class="math">\(\boldsymbol{e}^{\mathcal{M}}(\vec{x})\colon U^{n}\subseteq\Re^{n}\rightarrow \mathcal{V}\)</span> allows us to calculate an unormalized pseudo-scalar
for <span class="math">\(\mathcal{T}_{\vec{x}}(\mathcal{M})\)</span>,</p>
<div class="math">
\[  \begin{equation}
      I^{\mathcal{M}}(\vec{x}) = \boldsymbol{e}_{1}^{\mathcal{M}}(\vec{x})
                                         \wedge\dots\wedge \boldsymbol{e}_{m}^{\mathcal{M}}(\vec{x}).
  \end{equation}\]</div><p>With the pseudo-scalar we can define a projection operator from <span class="math">\(\mathcal{V}\)</span>
to the tangent space of <span class="math">\(\mathcal{M}\)</span> by</p>
<div class="math">
\[  \begin{equation}
      P_{\vec{x}}(v) = \left (v\cdot I^{\mathcal{M}}(\vec{x})\right)
                                \left (I^{\mathcal{M}}(\vec{x})\right )^{-1} \;\forall\; v\in\mathcal{V}.
  \end{equation}\]</div><p>In fact for each tangent space <span class="math">\(\mathcal{T}_{\vec{x}}(\mathcal{M})\)</span> we can define a geometric algebra
<span class="math">\(\mathcal{G}\left (\mathcal{T}_{\vec{x}}(\mathcal{M})\right )\)</span> with pseudo-scalar <span class="math">\(I^{\mathcal{M}}\)</span> so that if
<span class="math">\(A \in \mathcal{G}(\mathcal{V})\)</span> then</p>
<div class="math">
\[  \begin{equation}
      P_{\vec{x}}(A) = \left (A\cdot I^{\mathcal{M}}(\vec{x})\right )
                           \left (I^{\mathcal{M}}(\vec{x})\right )^{-1}
                           \in \mathcal{G}\left (\mathcal{T}_{\vec{x}}(\mathcal{M})\right )\;\forall\;
                           A \in \mathcal{G}(\mathcal{V})
  \end{equation}\]</div><p>and similarly for the submanifold <span class="math">\(\mathcal{N}\)</span>.</p>
<p>If the embedding <span class="math">\(\boldsymbol{e}^{\mathcal{M}}(\vec{x})\colon U^{n}\subseteq\Re^{n}\rightarrow \mathcal{V}\)</span> is not given,
but the metric tensor <span class="math">\(g_{ij}^{\mathcal{M}}(\vec{x})\)</span> is given, the geometric algebra of the
tangent space can be constructed.  Also the derivatives of the basis vectors of the tangent space can
be calculated from the metric tensor using the Christoffel symbols, <span class="math">\(\Gamma_{ij}^{k}(\vec{x})\)</span>, where
the derivatives of the basis vectors are given by</p>
<div class="math">
\[  \begin{equation}\label{eq_79a}
      \partial_{x^{i}}\boldsymbol{e}_{j}^{\mathcal{M}} = \Gamma_{ij}^{k}(\vec{x})\boldsymbol{e}_{k}^{\mathcal{M}}.
  \end{equation}\]</div><p>If we have a submanifold, <span class="math">\(\mathcal{N}\)</span>, defined by eq. (<span class="math">\(\ref{eq_79}\)</span>) we can calculate the metric of
<span class="math">\(\mathcal{N}\)</span> from eq. (<span class="math">\(\ref{eq_53}\)</span>) and hence construct the geometric algebra and calculus of the
tangent space, <span class="math">\(\mathcal{T}_{\vec{u}}(\mathcal{N})\subseteq \mathcal{T}_{\vec{x}(\vec{u})}{\mathcal{M}}\)</span>.</p>
<p>If the base manifold is normalized (use the hat symbol to denote normalized tangent vectors,
<span class="math">\(\boldsymbol{\hat{e}}_{i}^{\mathcal{M}}\)</span>, and the resulting metric tensor, <span class="math">\(\hat{g}_{ij}^{\mathcal{M}}\)</span> we have
<span class="math">\(\boldsymbol{\hat{e}}_{i}^{\mathcal{M}}\cdot\boldsymbol{\hat{e}}_{i}^{\mathcal{M}} = \pm 1\)</span> and <span class="math">\(\hat{g}_{ij}^{\mathcal{M}}\)</span> does
not posess enough
information to calculate <span class="math">\(g_{ij}^{\mathcal{N}}\)</span>.  In that case we need to know <span class="math">\(g_{ij}^{\mathcal{M}}\)</span>, the
metric tensor of the base manifold before normalization.  Likewise, for the case of a vector
manifold unless the mapping, <span class="math">\(\boldsymbol{e}^{\mathcal{M}}(\vec{x})\colon U^{m}\subseteq\Re^{m}\rightarrow \mathcal{V}\)</span>, is
constant the tangent vectors and metric tensor can only be normalized after the fact (one cannot have a
mapping that automatically normalizes all the tangent vectors).</p>
</div></blockquote>
</div>
<div class="section" id="geometric-derivative">
<span id="deriv"></span><h2>Geometric Derivative<a class="headerlink" href="#geometric-derivative" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>The directional derivative of a multivector field <span class="math">\(F(x)\)</span> is defined by (<span class="math">\(a\)</span> is a vector and <span class="math">\(h\)</span> is a scalar)</p>
<div class="math">
\[\begin{equation}\label{eq_50}
   (a\cdot\nabla_{x})F \equiv \lim_{h\rightarrow 0}\frac{F(x+ah)-F(x)}{h}.
\end{equation}\]</div><p>Note that <span class="math">\(a\cdot\nabla_{x}\)</span> is a scalar operator.  It will give a result containing only those grades
that are already in <span class="math">\(F\)</span>.  <span class="math">\((a\cdot\nabla_{x})F\)</span> is the best linear approximation of <span class="math">\(F(x)\)</span>
in the direction <span class="math">\(a\)</span>.  Equation (<span class="math">\(\ref{eq_50}\)</span>) also defines the operator <span class="math">\(\nabla_{x}\)</span> which for a set of
basis vectors, <span class="math">\(\left \{ \boldsymbol{e}_{i}\right \}\)</span>, has the representation (note that the <span class="math">\(\boldsymbol{e}^{j}\)</span> are reciprocal
basis vectors)</p>
<div class="math">
\[\begin{equation}
    \nabla_{x} F = \boldsymbol{e}^{j}\frac{\partial F}{\partial x^{j}}
\end{equation}\]</div><p>If <span class="math">\(F_{r}\)</span> is a <span class="math">\(r\)</span>-grade multivector (if the independent vector, <span class="math">\(x\)</span>, is obvious we suppress it in the
notation and just write <span class="math">\(\nabla\)</span>) and
<span class="math">\(F_{r} = F_{r}^{i_{1}\dots i_{r}}\boldsymbol{e}_{i_{1}}\wedge\dots\wedge \boldsymbol{e}_{i_{r}}\)</span>
then</p>
<div class="math">
\[\begin{equation}
  \nabla F_{r} = \frac{\partial F_{r}^{i_{1}\dots i_{r}}}{\partial x^{j}}\boldsymbol{e}^{j}\left ( \boldsymbol{e}_{i_{1}}\wedge
               \dots\wedge \boldsymbol{e}_{i_{r}} \right )
\end{equation}\]</div><p>Note that
<span class="math">\(\boldsymbol{e}^{j}\left (\boldsymbol{e}_{i_{1}}\wedge\dots\wedge \boldsymbol{e}_{i_{r}} \right )\)</span>
can only contain grades <span class="math">\(r-1\)</span> and <span class="math">\(r+1\)</span> so that <span class="math">\(\nabla F_{r}\)</span>
also can only contain those grades. For a grade-<span class="math">\(r\)</span> multivector
<span class="math">\(F_{r}\)</span> the inner (div) and outer (curl) derivatives are</p>
<div class="math">
\[\begin{equation}
\nabla\cdot F_{r} = \left < \nabla F_{r}\right >_{r-1} = \boldsymbol{e}^{j}\cdot \partial_{x^{j}}F_{r}
\end{equation}\]</div><p>and</p>
<div class="math">
\[\begin{equation}
\nabla\wedge F_{r} = \left < \nabla F_{r}\right >_{r+1} = \boldsymbol{e}^{j}\wedge \partial_{x^{j}}F_{r}
\end{equation}\]</div><p>For a general multivector function <span class="math">\(F\)</span> the inner and outer derivatives are
just the sum of the inner and outer dervatives of each grade of the multivector
function.</p>
</div></blockquote>
<div class="section" id="geometric-derivative-on-a-manifold">
<h3>Geometric Derivative on a Manifold<a class="headerlink" href="#geometric-derivative-on-a-manifold" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>In the case of a manifold the derivatives of the <span class="math">\(\boldsymbol{e}_{i}\)</span>&#8216;s are functions of the coordinates,
<span class="math">\(\left \{x^{i}\right \}\)</span>, so that the geometric derivative of a <span class="math">\(r\)</span>-grade multivector field is (Einstein summation
convention)</p>
<div class="math">
\[\begin{align}
      \nabla F_{r} &= \boldsymbol{e}^{i}\partial_{x^{i}}F_{r} = \boldsymbol{e}^{i}\partial_{x^{i}}
                     \left ( F_{r}^{i_{1}\dots i_{r}} \boldsymbol{e}_{i_{1}}\wedge\dots\wedge \boldsymbol{e}_{i_{r}}\right ) \nonumber \\
                   &= \partial_{x^{i}} F_{r}^{i_{1}\dots i_{r}} \boldsymbol{e}^{i}\left ( \boldsymbol{e}_{i_{1}}\wedge\dots\wedge \boldsymbol{e}_{i_{r}} \right )
                      +F_{r}^{i_{1}\dots i_{r}}\boldsymbol{e}^{i}\partial_{x^{i}}\left ( \boldsymbol{e}_{i_{1}}\wedge\dots\wedge \boldsymbol{e}_{i_{r}} \right )
\end{align}\]</div><p>where the multivector functions <span class="math">\(\boldsymbol{e}^{i}\partial_{x^{i}}\left (\boldsymbol{e}_{i_{1}}\wedge\dots\wedge \boldsymbol{e}_{i_{r}}\right )\)</span> are the
connection for the manifold.  We use the Christoffel symbols of the first kind
to calculate the derivatives of the basis vectors and the product rule to
calculate the derivatives of the basis blades where</p>
<div class="math">
\[\begin{equation}
  \Gamma_{ijk} = \frac{1}{2} \left ( \partial_{x^{i}}{g_{jk}}+\partial_{x^{j}}{g_{ik}}-\partial_{x^{k}}{g_{ij}}\right ),
\end{equation}\]</div><p>and</p>
<div class="math">
\[\begin{equation}
  \partial_{x^{i}}{ \boldsymbol{e}_{j}} = \Gamma_{ijk} \boldsymbol{e}^{k}.
\end{equation}\]</div><p>The Christoffel symbols of the second kind,</p>
<div class="math">
\[\begin{equation}
  \Gamma_{ij}^{k} = \frac{1}{2} g^{kl}\left ( \partial_{x^{j}}{g_{li}}+\partial_{x^{i}}{g_{lj}}-\partial_{x^{l}}{g_{ij}}\right ),
\end{equation}\]</div><p>could also be used to calculate the derivatives in term of the original basis vectors, but since we need to calculate the
reciprocal basis vectors for the geometric derivative
it is more efficient to use the symbols of the first kind.}</p>
<p>The directional (material/convective) derivative, <span class="math">\((v\cdot\nabla)F_{r}\)</span> is given by</p>
<div class="math">
\[\begin{align}
      \left ( v\cdot\nabla \right ) F_{r} &= v^{i}\partial_{x^{i}}{F_{r}} = v^{i}\partial_{x^{i}}
                     \left ( F_{r}^{i_{1}\dots i_{r}}\boldsymbol{e}_{i_{1}}\wedge\dots\wedge \boldsymbol{e}_{i_{r}}\right ) \nonumber \\
                   &= v^{i}\partial_{x^{i}}{F_{r}^{i_{1}\dots i_{r}}}\left ( \boldsymbol{e}_{i_{1}}\wedge\dots\wedge \boldsymbol{e}_{i_{r}} \right )
                      +v^{i}F_{r}^{i_{1}\dots i_{r}}\partial_{x^{i}}\left ( \boldsymbol{e}_{i_{1}}\wedge\dots\wedge \boldsymbol{e}_{i_{r}}\right ),
\end{align}\]</div><p>so that the multivector connection functions for the directional derivative are
<span class="math">\(\partial_{x^{i}}\left ( \boldsymbol{e}_{i_{1}}\wedge\dots\wedge \boldsymbol{e}_{i_{r}}\right )\)</span>. Be careful and note that
<span class="math">\((v\cdot\nabla) F_{r} \ne v\cdot \left (\nabla F_{r}\right )\)</span> since the dot and geometric products are
not associative with respect to one another (<span class="math">\(v\cdot\nabla\)</span> is a scalar operator).</p>
</div></blockquote>
<div class="section" id="normalizing-basis-for-derivatives">
<h4>Normalizing Basis for Derivatives<a class="headerlink" href="#normalizing-basis-for-derivatives" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><p>The basis vector set, <span class="math">\(\left \{ \boldsymbol{e}_{i}\right \}\)</span>, is not in general normalized.  We define a normalized set of basis
vectors, <span class="math">\(\left \{ \boldsymbol{\hat{e}}_{i}\right \}\)</span>, and reciprocal basis vectors, <span class="math">\(\left \{ \boldsymbol{\hat{e}}^{i}\right \}\)</span>, by</p>
<div class="math">
\[\begin{align}
    \boldsymbol{\hat{e}}_{i} &= \frac{\boldsymbol{e}_{i}}{\sqrt{\left | \left ( \boldsymbol{e}_{i}\right )^{2} \right |}} = \frac{\boldsymbol{e}_{i}}{\left | \boldsymbol{e}_{i}\right |}, \\
    \boldsymbol{\hat{e}}^{i} &= \frac{\boldsymbol{e}^{i}}{\sqrt{\left | \left (\boldsymbol{e}^{i}\right )^{2} \right |}} = \frac{\boldsymbol{e}^{i}}{\left | \boldsymbol{e}^{i}\right |}.
\end{align}\]</div><p>This works for all <span class="math">\(\boldsymbol{e}_{i}^{2} \neq 0\)</span>.  Note that  <span class="math">\(\boldsymbol{\hat{e}}_{i}^{2} = \pm 1\)</span> and <span class="math">\(\left (\boldsymbol{\hat{e}}^{i}\right )^{2} = \pm 1\)</span>.
Using the definition of reciprocal vectors we obtain the relationship between <span class="math">\(\left |\boldsymbol{e}_{i}\right |\)</span> and <span class="math">\(\left | \boldsymbol{e}^{i}\right |\)</span>,</p>
<div class="math">
\[\begin{align}
      \boldsymbol{e}^{i}\cdot \boldsymbol{e}_{j} &= \delta^{i}_{j} \nonumber \\
      \left | \boldsymbol{e}^{i}\right |\boldsymbol{\hat{e}}^{i}\cdot \left | \boldsymbol{e}_{j}\right |\boldsymbol{\hat{e}}_{j} &= \delta^{i}_{j} \nonumber \\
      \left | \boldsymbol{e}^{i}\right |\left | \boldsymbol{e}_{i}\right | &= 1 \nonumber \\
      \left | \boldsymbol{e}^{i}\right | &= \frac{1}{\left | \boldsymbol{e}_{i}\right |}.
\end{align}\]</div><p>Thus the geometric derivative for a set of normalized basis vectors is (we assume that
<span class="math">\(F_{r} = F_{r}^{i_{1}\dots i_{r}} \boldsymbol{\hat{e}}_{i_{1}}\wedge\dots\wedge \boldsymbol{\hat{e}}_{i_{r}}\)</span>)</p>
<div class="math">
\[\begin{equation}
      \nabla F_{r} =  \boldsymbol{e}^{i}\partial_{x^{i}}{F_{r}} = \frac{\boldsymbol{\hat{e}}^{i}}{\left |  \boldsymbol{e}_{i}\right |}\partial_{x^{i}}{F_{r}}
                   =\partial_{x^{i}}{F_{r}^{i_{1}\dots i_{r}}}\frac{\boldsymbol{\hat{e}}^{i}}{\left | \boldsymbol{e}_{i}\right |}
                     \left ( \boldsymbol{\hat{e}}_{i_{1}}\wedge\dots\wedge\boldsymbol{\hat{e}}_{i_{r}}\right )
                      +F_{r}^{i_{1}\dots i_{r}}\frac{\boldsymbol{\hat{e}}^{i}}{\left | \boldsymbol{e}_{i}\right |}\partial_{x^{i}}
                      \left ( \boldsymbol{\hat{e}}_{i_{1}}\wedge\dots\wedge\boldsymbol{\hat{e}}_{i_{r}}\right ).
\end{equation}\]</div><p>Additionally, one can calculate the connection of the normalized basis as follows</p>
<div class="math">
\[\begin{align}
      \partial_{x^{j}}\boldsymbol{e}_{i} =& \partial_{x^{j}}\left ( \left | \boldsymbol{e}_{i}\right |\boldsymbol{\hat{e}}_{i}\right ) = \Gamma_{jik}\boldsymbol{e}^{k}, \nonumber \\
      \partial_{x^{j}}\left | \boldsymbol{e}_{i}\right |\boldsymbol{\hat{e}}_{i}
                                        +\left | \boldsymbol{e}_{i}\right |\partial_{x^{j}}\boldsymbol{\hat{e}}_{i} =& \Gamma_{jik}\boldsymbol{e}^{k}, \nonumber \\
      \partial_{x^{j}}\left | \boldsymbol{e}_{i}\right |\boldsymbol{\hat{e}}_{i}
                                        +\left | \boldsymbol{e}_{i}\right |\partial_{x^{j}}\boldsymbol{\hat{e}}_{i} =& \frac{1}{\left | \boldsymbol{e}_{k}\right |}\Gamma_{jik}\boldsymbol{\hat{e}}^{k}, \nonumber \\
      \partial_{x^{j}}\boldsymbol{\hat{e}}_{i} =& \frac{1}{\left | \boldsymbol{e}_{i}\right |}\left ( \frac{1}{\left | \boldsymbol{e}_{k}\right |}\Gamma_{jik}\boldsymbol{\hat{e}}_{k}
                                         -\partial_{x^{j}}\left | \boldsymbol{e}_{i}\right |\boldsymbol{\hat{e}}_{i}\right ), \nonumber \\
                                      =& \frac{1}{\left | \boldsymbol{e}_{i}\right |\left | \boldsymbol{e}_{k}\right |}\Gamma_{jik}\boldsymbol{\hat{e}}_{k}
                                         -\frac{1}{\left | \boldsymbol{e}_{i}\right |}\partial_{x^{j}}\left | \boldsymbol{e}_{i}\right |\boldsymbol{\hat{e}}_{i},  \nonumber \\
                                      =& \frac{1}{\left | \boldsymbol{e}_{i}\right |\left | \boldsymbol{e}_{k}\right |}\Gamma_{jik}\boldsymbol{\hat{e}}_{k}
                                         -\frac{1}{2g_{ii}}\partial_{x^{j}}g_{ii}\boldsymbol{\hat{e}}_{i}.
\end{align}\]</div></div></blockquote>
</div>
<div class="section" id="linear-differential-operators">
<span id="dops"></span><h4>Linear Differential Operators<a class="headerlink" href="#linear-differential-operators" title="Permalink to this headline">¶</a></h4>
<blockquote>
<div><p>First a note on partial derivative notation.  We shall use the following notation for a partial derivative where
the manifold coordinates are <span class="math">\(x_{1},\dots,x_{n}\)</span>:</p>
<div class="math">
\[  \begin{equation}\label{eq_66a}
      \frac{\partial^{j_{1}+\cdots+j_{n}}}{\partial x_{1}^{j_{1}}\dots\partial x_{n}^{j_{n}}} = \partial_{j_{1}\dots j_{n}}.
  \end{equation}\]</div><p>If <span class="math">\(j_{k}=0\)</span> the partial derivative with respect to the <span class="math">\(k^{th}\)</span> coordinate is not taken.  If the <span class="math">\(j_{k} = 0\)</span> for all
<span class="math">\(1 \le k \le n\)</span> then the partial derivative operator is the scalar one.  If we consider a partial derivative where the <span class="math">\(x\)</span>&#8216;s are
not in normal order such as</p>
<div class="math">
\[  \begin{equation}
      \frac{\partial^{j_{1}+\cdots+j_{n}}}{\partial x_{i_{1}}^{j_{1}}\dots\partial x_{i_{n}}^{j_{n}}},
  \end{equation}\]</div><p>and the <span class="math">\(i_{k}\)</span>&#8216;s are not in ascending order.  The derivative can always be  put in the form in eq (<span class="math">\(\ref{eq_66a}\)</span>) since the order
of differentiation does not change the value of the partial derivative (for the smooth functions we are considering).
Additionally, using our notation the product of two partial derivative operations is given by</p>
<div class="math">
\[  \begin{equation}
      \partial_{i_{1}\dots i_{n}}\partial_{j_{1}\dots j_{n}} = \partial_{i_{1}+j_{1},\dots, i_{n}+j_{n}}.
  \end{equation}\]</div><p>A general general multivector linear differential operator is a linear combination of multivectors and partial derivative operators
denoted by (in all of this section we will use the Einstein summation convention)</p>
<div class="math">
\[  \begin{equation}\label{eq_66b}
      D \equiv D^{i_{1}\dots i_{n}}\partial_{i_{1}\dots i_{n}}.
  \end{equation}\]</div><p>Equation (<span class="math">\(\ref{eq_66b}\)</span>) is the normal form of the differential operator in that the partial derivative operators are written to the right
of the multivector coefficients and do not operate upon the multivector coefficients.
The operator of eq (<span class="math">\(\ref{eq_66b}\)</span>) can operate on mulitvector functions, returning a multivector function via the following definitions.</p>
<p><span class="math">\(F\)</span> as (Einstein summation convention)</p>
<div class="math">
\[  \begin{equation}\label{eq_67a}
      D\circ F = D^{j_{1}\dots j_{n}}\circ\partial_{j_{1}\dots j_{n}}F,
  \end{equation}\]</div><p>or</p>
<div class="math">
\[  \begin{equation}\label{eq_68a}
      F\circ D = \partial_{j_{1}\dots j_{n}}F\circ D^{j_{1}\dots j_{n}},
  \end{equation}\]</div><p>where the <span class="math">\(D^{j_{1}\dots j_{n}}\)</span> are multivector functions and <span class="math">\(\circ\)</span> is any of the multivector multiplicative operations.</p>
<p>Equations (<span class="math">\(\ref{eq_67a}\)</span>) and (<span class="math">\(\ref{eq_68a}\)</span>) are not the most general multivector linear differential operators, the most general would be</p>
<div class="math">
\[  \begin{equation}
      D(F) = D^{j_{1}\dots j_{n}}\left (\partial_{j_{1}\dots j_{n}}F\right ),
  \end{equation}\]</div><p>where <span class="math">\(D^{j_{1}\dots j_{n}}\left (\right )\)</span> are linear multivector functionals.</p>
<p>The definition of the sum of two differential operators is obvious since any multivector operator, <span class="math">\(\circ\)</span>, is a bilinear operator
<span class="math">\(\left (\left ( D_{A}+D_{B}\right )\circ F = D_{A}\circ F+D_{B}\circ F\right )\)</span>, the product of two differential operators <span class="math">\(D_{A}\)</span> and <span class="math">\(D_{B}\)</span>
operating on a multivector function <span class="math">\(F\)</span> is defined to be (<span class="math">\(\circ_{1}\)</span> and <span class="math">\(\circ_{2}\)</span> are any two multivector multiplicative operations)</p>
<div class="math">
\[  \begin{align}
      \left ( D_{A}\circ_{1}D_{B}\right )\circ_{2}F &\equiv \left ( D_{A}^{i_{1}\dots i_{n}}\circ_{1}
                                                    \partial_{i_{1}\dots i_{n}}\left ( D_{B}^{j_{1}\dots j_{n}}
                                                    \partial_{j_{1}\dots j_{n}}\right )\right )\circ_{2}F \nonumber \\
                                            &= \left (D_{A}^{i_{1}\dots i_{n}}\circ_{1}
                                               \left ( \left (\partial_{i_{1}\dots i_{n}}D_{B}^{j_{1}\dots j_{n}}\right )
                                               \partial_{j_{1}\dots j_{n}}+
                                               D_{B}^{j_{1}\dots j_{n}}\right )
                                               \partial_{i_{1}+j_{1},\dots, i_{n}+j_{n}}\right )\circ_{2}F \nonumber \\
                                            &= \left ( D_{A}^{i_{1}\dots i_{n}}\circ_{1}\left (\partial_{i_{1}\dots i_{n}}D_{B}^{j_{1}\dots j_{n}}\right )
                                               \right )\circ_{2}\partial_{j_{1}\dots j_{n}}F+
                                               \left (D_{A}^{i_{1}\dots i_{n}}\circ_{1}D_{B}^{j_{1}\dots j_{n}}\right )
                                               \circ_{2}\partial_{i_{1}+j_{1},\dots, i_{n}+j_{n}}F,
  \end{align}\]</div><p>where we have used the fact that the <span class="math">\(\partial\)</span> operator is a scalar operator and commutes with <span class="math">\(\circ_{1}\)</span> and <span class="math">\(\circ_{2}\)</span>.</p>
<p>Thus for a pure operator product <span class="math">\(D_{A}\circ D_{B}\)</span> we have</p>
<div class="math">
\[  \begin{equation}\label{eq_71a}
      D_{A}\circ D_{B} = \left ( D_{A}^{i_{1}\dots i_{n}}\circ\left ( \partial_{i_{1}\dots i_{n}}D_{B}^{j_{1}\dots j_{n}}\right )\right )
                                               \partial_{j_{1}\dots j_{n}}+
                                               \left (D_{A}^{i_{1}\dots i_{n}}\circ_{1}D_{B}^{j_{1}\dots j_{n}}\right )
                                               \partial_{i_{1}+j_{1},\dots, i_{n}+j_{n}}
  \end{equation}\]</div><p>and the form of eq (<span class="math">\(\ref{eq_71a}\)</span>) is the same as eq(<span class="math">\(\ref{eq_67a}\)</span>).  The basis of eq (<span class="math">\(\ref{eq_71a}\)</span>) is that the <span class="math">\(\partial\)</span> operator
operates on all object to the right of it as products so that the product rule must be used in all differentiations.  Since eq (<span class="math">\(\ref{eq_71a}\)</span>)
puts the product of two differential operators in standard form we also evaluate <span class="math">\(F\circ_{2}\left (D_{A}\circ_{1}D_{B}\right )\)</span>.</p>
<p>We now must distinguish between the following cases.  If <span class="math">\(D\)</span> is a differential operator and <span class="math">\(F\)</span> a multivector function should <span class="math">\(D\circ F\)</span> and
<span class="math">\(F\circ D\)</span> return a differential operator or a multivector. In order to be consistent with the standard vector analysis we have <span class="math">\(D\circ F\)</span>
return a multivector and <span class="math">\(F\circ D\)</span> return a differential operator.  The we define the complementary differential operator <span class="math">\(\bar{D}\)</span> which
is identical to <span class="math">\(D\)</span> except that <span class="math">\(\bar{D}\circ F\)</span> returns a differential operator according to eq (<span class="math">\(\ref{eq_71a}\)</span>) <a class="footnote-reference" href="#f0" id="id7">[1]</a> and <span class="math">\(F\circ\bar{D}\)</span> returns a multivector according to eq (<span class="math">\(\ref{eq_68a}\)</span>).</p>
<p>A general differential operator is built from repeated applications of the basic operator building blocks <span class="math">\(\left )\bar{\nabla}\circ A\right )\)</span>,
<span class="math">\((A\circ\bar{\nabla})\)</span>, <span class="math">\((\bar{\nabla}\circ\bar{\nabla})\)</span>, and <span class="math">\((A\pm \bar{\nabla})\)</span>.  Both <span class="math">\(\nabla\)</span> and
<span class="math">\(\bar{\nabla}\)</span> are represented by the operator</p>
<div class="math">
\[  \begin{equation}
      \nabla = \bar{\nabla} = \boldsymbol{e}^{i}\partial_{x^{i}},
  \end{equation}\]</div><p>but are flagged to produce the appropriate result.</p>
<p>In the our notation the directional derivative operator is <span class="math">\(a\cdot\nabla\)</span>, the Laplacian
<span class="math">\(\nabla\cdot\nabla\)</span> and the expression for the Riemann tensor, <span class="math">\(R^{i}_{jkl}\)</span>, is</p>
<div class="math">
\[  \begin{equation}
      {(\nabla\wedge\nabla}) \boldsymbol{e}^{i} = \frac{1}{2}R^{i}_{jkl}\left (  \boldsymbol{e}^{j}\wedge \boldsymbol{e}^{k}\right ) \boldsymbol{e}^{l}.
  \end{equation}\]</div><p>We would use the complement if we wish a quantum mechanical type commutator defining</p>
<div class="math">
\[  \begin{equation}
      [x,\nabla] \equiv x\nabla - \bar{\nabla}x,
  \end{equation}\]</div><p>or if we wish to simulate the dot notation (Doran and Lasenby)</p>
<div class="math">
\[  \begin{equation}
      \dot{F}\dot{\nabla} = F\bar{\nabla}.
  \end{equation}\]</div></div></blockquote>
</div>
</div>
</div>
<div class="section" id="linear-transformations">
<span id="ltrans"></span><h2>Linear Transformations<a class="headerlink" href="#linear-transformations" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>In the tangent space of a manifold, <span class="math">\(\mathcal{M}\)</span>, (which is a vector space) a linear transformation is the mapping
<span class="math">\(\underline{T}\colon\mathcal{T}_{\vec{x}}\left (\mathcal{M}\right )\rightarrow\mathcal{T}_{\vec{x}}\left (\mathcal{M}\right )\)</span>
(we use an underline to indicate
a linear transformation) where for all <span class="math">\(x,y\in \mathcal{T}_{\vec{x}}\left (\mathcal{M}\right )\)</span> and <span class="math">\(\alpha\in\Re\)</span> we have</p>
<div class="math">
\[  \begin{align}
      \underline{T}(x+y) =& \underline{T}(x) + \underline{T}(y) \\
      \underline{T}(\alpha x) =& \alpha\underline{T}(x)
  \end{align}\]</div><p>The outermorphism induced by <span class="math">\(\underline{T}\)</span> is defined for <span class="math">\(x_{1},\dots,x_{r}\in\mathcal{T}_{\vec{x}}\left (\mathcal{M}\right )\)</span> where
<span class="math">\(r\le\dim\left (\mathcal{T}_{\vec{x}}\left (\mathcal{M}\right )\right )\)</span></p>
<div class="math">
\[  \begin{equation}
      \underline{T}\left (x_{1}\wedge\dots\wedge x_{r}\right ) \equiv \underline{T}\left (x_{1}\right )\wedge\dots\wedge\underline{T}\left (x_{r} \right )
  \end{equation}\]</div><p>If <span class="math">\(I\)</span> is the pseudo scalar for <span class="math">\(\mathcal{T}_{\vec{x}}\left (\mathcal{M}\right )\)</span> we also have the following
definitions for determinate, trace, and adjoint (<span class="math">\(\overline{T}\)</span>) of <span class="math">\(\underline{T}\)</span> <a class="footnote-reference" href="#f1" id="id8">[2]</a>, <a class="footnote-reference" href="#f2" id="id9">[3]</a></p>
<div class="math">
\[  \begin{align}
      \underline{T}(I) \equiv&\; \det\left (\underline{T}\right )I \\
      \mbox{tr}\left (\underline{T}\right ) \equiv&\; \nabla_{y}\cdot\underline{T}(y) \\
      x\cdot \overline{T}(y) \equiv&\; y\cdot \underline{T}(x).
  \end{align}\]</div><p>If <span class="math">\(\left \{ \boldsymbol{e}_{i}\right \}\)</span> is a basis for <span class="math">\(\mathcal{T}_{\vec{x}}\left (\mathcal{M}\right )\)</span> then we can represent <span class="math">\(\underline{T}\)</span> with the matrix <span class="math">\(\underline{T}_{i}^{j}\)</span> used
as follows (Einstein summation convention as usual) -</p>
<div class="math">
\[  \begin{equation}\label{eq_97}
      \underline{T}\left( \boldsymbol{e}_{i}\right ) = \underline{T}_{i}^{j}\boldsymbol{e}_{j}.
  \end{equation}\]</div><p>In eq. (<span class="math">\(\ref{eq_97}\)</span>) the matrix, <span class="math">\(\underline{T}_{i}^{j}\)</span>, only has it&#8217;s usual meaning if the <span class="math">\(\left \{ \boldsymbol{e}_{i}\right \}\)</span> form an orthonormal Euclidan
basis (Minkowski spaces not allowed). Equations (<span class="math">\(\ref{eq_98}\)</span>) through (<span class="math">\(\ref{eq_100}\)</span>) become</p>
<div class="math">
\[  \begin{align}
      \det\left (\underline{T}\right ) =&\; \underline{T}\left (\boldsymbol{e}_{1}\wedge\dots\wedge\boldsymbol{e}_{n}\right )
                           \left (\boldsymbol{e}_{1}\wedge\dots\wedge\boldsymbol{e}_{n}\right )^{-1}, \label{eq_98}\\
      \mbox{tr}\left (\underline{T} \right ) =&\; \underline{T}_{i}^{i},\\
      \overline{T}_{j}^{i} =&\;  g^{il}g_{jp}\underline{T}_{l}^{p}.\label{eq_100}
  \end{align}\]</div></div></blockquote>
</div>
<div class="section" id="multi-linear-transformations-tensors">
<span id="mltrans"></span><h2>Multi-Linear Transformations (Tensors)<a class="headerlink" href="#multi-linear-transformations-tensors" title="Permalink to this headline">¶</a></h2>
<p>A multivector multilinear function is a
multivector function <span class="math">\(T \paren{ A_{1},\dots,A_{r}}\)</span> that is linear in each of it arguments (it could be implicitly
non-linearly dependent on a set of additional arguments such as the postion coordinates, but we only consider the linear arguments).
<span class="math">\(T\)</span> is a <em>tensor</em> of degree <span class="math">\(r\)</span> if each variable <span class="math">\(A_{j}\)</span> is restricted to the vector space <span class="math">\(\mathcal{V}_{n}\)</span>.
More generally if each <span class="math">\(A_{j}\in \mathcal{G}\left (\mathcal{V}_{n}\right )\)</span> (the geometric algebra of <span class="math">\(\mathcal{V}_{n}\)</span>),
we call <span class="math">\(T\)</span> an <em>extensor</em> of degree-<span class="math">\(r\)</span> on <span class="math">\(\mathcal{G}\left ( \mathcal{V}_{n}\right )\)</span>.</p>
<p>If the values of <span class="math">\(T\left (a_{1},\dots,a_{r}\right )\)</span> <span class="math">\(\left ( a_{j}\in\mathcal{V}_{n}\;\forall\; 1\le j \le r \right )\)</span>
are <span class="math">\(s\)</span>-vectors (pure grade <span class="math">\(s\)</span> multivectors in <span class="math">\(\mathcal{G}\paren{\mathcal{V}_{n}}\)</span> we say that
<span class="math">\(T\)</span> has grade <span class="math">\(s\)</span> and rank <span class="math">\(r+s\)</span>.  A tensor of grade zero is called a <em>multilinear form</em>.</p>
<p>In the normal definition of tensors as multilinear functions the tensor is defined as a mapping</p>
<blockquote>
<div><div class="math">
\[  \begin{equation}

      T:\bigotimes_{i=1}^{r}\mathcal{V}_{i}\rightarrow\Re,

  \end{equation}\]</div></div></blockquote>
<p>so that the standard tensor definition is an example of a grade zero
degree/rank <span class="math">\(r\)</span> tensor in our definition.</p>
<div class="section" id="algebraic-operations">
<h3>Algebraic Operations<a class="headerlink" href="#algebraic-operations" title="Permalink to this headline">¶</a></h3>
<p>The properties of tensors are (<span class="math">\(\alpha\in\Re\)</span>, <span class="math">\(a_{j},b\in\mathcal{V}_{n}\)</span>, <span class="math">\(T\)</span> and <span class="math">\(S\)</span> are tensors of
rank <span class="math">\(r\)</span>, and <span class="math">\(\circ\)</span> is any multivector multiplicative operation)</p>
<blockquote>
<div><div class="math">
\[  \begin{align}
      T\left (a_{1},\dots,\alpha a_{j},\dots,a_{r}\right ) =& \alpha T\left (a_{1},\dots,a_{j},\dots,a_{r}\right ), \\
      T\left (a_{1},\dots,a_{j}+b,\dots,a_{r}\right ) =& T\left (a_{1},\dots,a_{j},\dots,a_{r}\right ) +
                                                       T\left (a_{1},\dots,a_{j-1},b,a_{j+1},\dots,a_{r}\right ), \\
      \left ( T\pm S\right )\left (a_{1},\dots,a_{r}\right ) \equiv& T\left (a_{1},\dots,a_{r} \right )
                   \pm S\left (a_{1},\dots,a_{r}\right).
  \end{align}\]</div></div></blockquote>
<p>Now let <span class="math">\(T\)</span> be of rank <span class="math">\(r\)</span> and <span class="math">\(S\)</span> of rank <span class="math">\(s\)</span> then the product of the two tensors is</p>
<blockquote>
<div><div class="math">
\[  \begin{equation}

      \left ( T\circ S\right )\left (a_{1},\dots,a_{r+s}\right ) \equiv T\left (a_{1},\dots,a_{r}\right )
                 \circ S\left (a_{r+1},\dots,a_{r+s}\right ),

  \end{equation}\]</div></div></blockquote>
<p>where &#8220;<span class="math">\(\circ\)</span>&#8221; is any multivector multiplicative operation.</p>
</div>
<div class="section" id="covariant-contravariant-and-mixed-representations">
<h3>Covariant, Contravariant, and Mixed Representations<a class="headerlink" href="#covariant-contravariant-and-mixed-representations" title="Permalink to this headline">¶</a></h3>
<p>The arguments (vectors) of the multilinear fuction can be represented in terms of the basis vectors or the reciprocal basis vectors</p>
<blockquote>
<div><div class="math">
\[  \begin{align}
      a_{j} =& a^{i_{j}}\eb_{i_{j}}, \\
            =& a_{i_{j}}\eb^{i_{j}}.
  \end{align}\]</div></div></blockquote>
<p>These equations gives <span class="math">\(a_{j}\)</span> in terms of the basis vectors or the reciprocal basis vectors. The index
<span class="math">\(j\)</span> refers to the argument slot and the indices <span class="math">\(i_{j}\)</span> the components of the vector in terms of the basis.  The Einstein summation
convention is used throughout.  The covariant representation of the tensor is defined by</p>
<blockquote>
<div><div class="math">
\[  \begin{align}
      T_{i_{1}\dots i_{r}} \equiv& \f{T}{\eb_{i_{1}},\dots,\eb_{i_{r}}} \\
      \f{T}{a_{1},\dots,a_{r}} =& \f{T}{a^{i_{1}}\eb_{i_{1}},\dots,a^{i_{r}}\eb_{i_{r}}} \nonumber \\
                               =& \f{T}{\eb_{i_{1}},\dots,\eb_{i_{r}}}a^{i_{1}}\dots a^{i_{r}} \nonumber \\
                               =& T_{i_{1}\dots i_{r}}a^{i_{1}}\dots a^{i_{r}}.
  \end{align}\]</div></div></blockquote>
<p>Likewise for the contravariant representation</p>
<blockquote>
<div><div class="math">
\[  \begin{align}
      T^{i_{1}\dots i_{r}} \equiv& \f{T}{\eb^{i_{1}},\dots,\eb^{i_{r}}} \\
      \f{T}{a_{1},\dots,a_{r}} =& \f{T}{a_{i_{1}}\eb^{i_{1}},\dots,a_{i_{r}}\eb^{i_{r}}} \nonumber \\
                               =& \f{T}{\eb^{i_{1}},\dots,\eb^{i_{r}}}a_{i_{1}}\dots a_{i_{r}} \nonumber \\
                               =& T^{i_{1}\dots i_{r}}a_{i_{1}}\dots a_{i_{r}}.
  \end{align}\]</div></div></blockquote>
<p>One could also have a mixed representation</p>
<blockquote>
<div><div class="math">
\[  \begin{align}
      T_{i_{1}\dots i_{s}}^{i_{s+1}\dots i_{r}} \equiv& \f{T}{\eb_{i_{1}},\dots,\eb_{i_{s}},\eb^{i_{s+1}}\dots\eb^{i_{r}}} \\
      \f{T}{a_{1},\dots,a_{r}} =& \f{T}{a^{i_{1}}\eb_{i_{1}},\dots,a^{i_{s}}\eb_{i_{s}},
                                  a_{i_{s+1}}\eb^{i_{s}}\dots,a_{i_{r}}\eb^{i_{r}}} \nonumber \\
                               =& \f{T}{\eb_{i_{1}},\dots,\eb_{i_{s}},\eb^{i_{s+1}},\dots,\eb^{i_{r}}}
                                  a^{i_{1}}\dots a^{i_{s}},a_{i_{s+1}},\dots a_{i_{r}} \nonumber \\
                               =& T_{i_{1}\dots i_{s}}^{i_{s+1}\dots i_{r}}a^{i_{1}}\dots a^{i_{s}},a_{i_{s+1}},\dots a_{i_{r}}.
  \end{align}\]</div></div></blockquote>
<p>In the representation of <span class="math">\(T\)</span> one could have any combination of covariant (lower) and contravariant (upper) indices.</p>
<p>To convert a covariant index to a contravariant index simply consider</p>
<blockquote>
<div><div class="math">
\[  \begin{align}
      \f{T}{\eb_{i_{1}},\dots,\eb^{i_{j}},\dots,\eb_{i_{r}}} =& \f{T}{\eb_{i_{1}},\dots,g^{i_{j}k_{j}}\eb_{k_{j}},\dots,\eb_{i_{r}}} \nonumber \\
                                                             =& g^{i_{j}k_{j}}\f{T}{\eb_{i_{1}},\dots,\eb_{k_{j}},\dots,\eb_{i_{r}}} \nonumber \\
      T_{i_{1}\dots i_{j-1}i_{j+1}\dots i_{r}}^{i_{j}} =& g^{i_{j}k_{j}}T_{i_{1}\dots i_{j}\dots i_{r}}.
  \end{align}\]</div></div></blockquote>
<p>Similarly one could lower an upper index with <span class="math">\(g_{i_{j}k_{j}}\)</span>.</p>
</div>
<div class="section" id="contraction-and-differentiation">
<h3>Contraction and Differentiation<a class="headerlink" href="#contraction-and-differentiation" title="Permalink to this headline">¶</a></h3>
<p>The contraction of a tensor between the <span class="math">\(j^{th}\)</span> and <span class="math">\(k^{th}\)</span> variables (slots) is</p>
<blockquote>
<div><div class="math">
\[  \be
      \f{T}{a_{i},\dots,a_{j-1},\nabla_{a_{k}},a_{j+1},\dots,a_{r}} = \nabla_{a_{j}}\cdot\lp\nabla_{a_{k}}\f{T}{a_{1},\dots,a_{r}}\rp.
  \ee\]</div></div></blockquote>
<p>This operation reduces the rank of the tensor by two.  This definition gives the standard results for <em>metric contraction</em> which is
proved as follows for a rank <span class="math">\(r\)</span> grade zero tensor (the circumflex &#8220;<span class="math">\(\breve{\:\:}\)</span>&#8221; indicates that a term is to be deleted from the product).</p>
<blockquote>
<div><div class="math">
\[  \begin{align}
      \f{T}{a_{1},\dots,a_{r}} =& a^{i_{1}}\dots a^{i_{r}}T_{i_{1}\dots i_{r}} \\
      \nabla_{a_{j}}T =& \eb^{l_{j}} a^{i_{1}}\dots\lp\partial_{a^{l_j}}a^{i_{j}}\rp\dots a_{i_{r}}T_{i_{1}\dots i_{r}} \nonumber \\
      =& \eb^{l_{j}}\delta_{l_{j}}^{i_{j}} a^{i_{1}}\dots \breve{a}^{i_{j}}\dots a^{i_{r}}T_{i_{1}\dots i_{r}} \\
      \nabla_{a_{m}}\cdot\lp\nabla_{a_{j}}T\rp =& \eb^{k_{m}}\cdot\eb^{l_{j}}\delta_{l_{j}}^{i_{j}}
                                                a^{i_{1}}\dots \breve{a}^{i_{j}}\dots\lp\partial_{a^{k_m}}a^{i_{m}}\rp
                                                \dots a^{i_{r}}T_{i_{1}\dots i_{r}} \nonumber \\
                                               =& g^{k_{m}l_{j}}\delta_{l_{j}}^{i_{j}}\delta_{k_{m}}^{i_{m}}
                                                a^{i_{1}}\dots \breve{a}^{i_{j}}\dots\breve{a}^{i_{m}}
                                                \dots a^{i_{r}}T_{i_{1}\dots i_{r}} \nonumber \\
                                               =& g^{i_{m}i_{j}}a^{i_{1}}\dots \breve{a}^{i_{j}}\dots\breve{a}^{i_{m}}
                                                \dots a^{i_{r}}T_{i_{1}\dots i_{j}\dots i_{m}\dots i_{r}} \nonumber \\
                                               =& g^{i_{j}i_{m}}a^{i_{1}}\dots \breve{a}^{i_{j}}\dots\breve{a}^{i_{m}}
                                                \dots a^{i_{r}}T_{i_{1}\dots i_{j}\dots i_{m}\dots i_{r}}  \nonumber \\
                                               =& \lp g^{i_{j}i_{m}}T_{i_{1}\dots i_{j}\dots i_{m}\dots i_{r}}\rp a^{i_{1}}\dots
                                                \breve{a}^{i_{j}}\dots\breve{a}^{i_{m}}\dots a^{i_{r}}\label{eq108}
  \end{align}\]</div></div></blockquote>
<p>Equation <span class="math">\(\eqref{eq108}\)</span> is the correct formula for the metric contraction of a tensor.</p>
<p>Finally if <span class="math">\(\f{T}{a_{1},\dots,a_{r}}\)</span> is a tensor field (implicitly a function of position) the tensor derivative is defined as</p>
<blockquote>
<div><div class="math">
\[  \begin{align}
      \f{T}{a_{1},\dots,a_{r};a_{r+1}} \equiv \lp a_{r+1}\cdot\nabla\rp\f{T}{a_{1},\dots,a_{r}},
  \end{align}\]</div></div></blockquote>
<p>assuming the <span class="math">\(a^{i_{j}}\)</span> coefficients are not a function of the coordinates.</p>
<p>This gives for a grade zero rank <span class="math">\(r\)</span> tensor</p>
<blockquote>
<div><div class="math">
\[  \begin{align}
      \lp a_{r+1}\cdot\nabla\rp\f{T}{a_{1},\dots,a_{r}} =& a^{i_{r+1}}\partial_{x^{i_{r+1}}}a^{i_{1}}\dots a^{i_{r}}
                                                          T_{i_{1}\dots i_{r}}, \nonumber \\
                                                       =& a^{i_{1}}\dots a^{i_{r}}a^{i_{r+1}}
                                                          \partial_{x^{i_{r+1}}}T_{i_{1}\dots i_{r}}.
  \end{align}\]</div></div></blockquote>
</div>
<div class="section" id="covariant-deriviatives">
<h3>Covariant Deriviatives<a class="headerlink" href="#covariant-deriviatives" title="Permalink to this headline">¶</a></h3>
<p>The component free form of the covariant derivative (the one used to calculate it in the code) is</p>
<blockquote>
<div><div class="math">
\[  \begin{equation}\label{cderiv}
      \mathcal{D}_{a_{r+1}} \f{T}{a_{1},\dots,a_{r};x} \equiv \nabla T
          - \sum_{k=1}^{r}\f{T}{a_{1},\dots,\paren{a_{r+1}\cdot\nabla} a_{k},\dots,a_{r};x}.
  \end{equation}\]</div></div></blockquote>
<p>The effect of <span class="math">\(\paren{a_{r+1}\cdot\nabla} a_{k}\)</span> in equation <span class="math">\(\eqref{cderiv}\)</span> is to
parallel transport  <span class="math">\(a_{k}\)</span> in the direction of <span class="math">\(a_{r+1}\)</span> which gives the standard definition of the covariant derivative
of a tensor field.  Note that  <span class="math">\(a_{k} = a_{k}^{j}\bm{e}_{k}\)</span> where <span class="math">\(a_{k}^{j}\)</span> is not
a function of the coordinates, but in general <span class="math">\(\bm{e}_{k}\)</span> is a function of the coordinates.</p>
</div>
</div>
<div class="section" id="numpy-latex-and-ansicon-installation">
<h2>Numpy, LaTeX, and Ansicon Installation<a class="headerlink" href="#numpy-latex-and-ansicon-installation" title="Permalink to this headline">¶</a></h2>
<p>To install the geometric algebra module on windows,linux, or OSX perform the following operations</p>
<blockquote>
<div><ol class="arabic">
<li><p class="first">Install sympy.  <em>galgebra</em> is included in sympy.</p>
</li>
<li><p class="first">To install texlive in linux or windows</p>
<blockquote>
<div><ol class="arabic simple">
<li>Go to &lt;<a class="reference external" href="http://www.tug.org/texlive/acquire-netinstall.html">http://www.tug.org/texlive/acquire-netinstall.html</a>&gt; and click on &#8220;install-tl.zip&#8221; to download</li>
<li>Unzip &#8220;install-tl.zip&#8221; anywhere on your machine</li>
<li>Open the file &#8220;readme.en.html&#8221; in the &#8220;readme-html.dir&#8221; directory.  This file contains the information needed to install texlive.</li>
<li>Open a terminal (console) in the &#8220;install-tl-XXXXXX&#8221; directory</li>
<li>Follow the instructions in &#8220;readme.en.html&#8221; file to run the install-tl.bat file in windows or the install-tl script file in linux.</li>
</ol>
</div></blockquote>
</li>
<li><p class="first">For OSX install mactex from &lt;<a class="reference external" href="http://tug.org/mactex/">http://tug.org/mactex/</a>&gt;.</p>
</li>
<li><p class="first">Install python-nympy if you want to calculate numerical matrix functons (determinant, inverse, eigenvalues, etc.).
For windows go to &lt;<a class="reference external" href="http://sourceforge.net/projects/numpy/files/NumPy/1.6.2/">http://sourceforge.net/projects/numpy/files/NumPy/1.6.2/</a>&gt; and install the distribution of numpy
appropriate for your system.  For OSX go to &lt;<a class="reference external" href="http://sourceforge.net/projects/numpy/files/NumPy/1.6.1/">http://sourceforge.net/projects/numpy/files/NumPy/1.6.1/</a>&gt;.</p>
</li>
<li><p class="first">It is strongly suggested that you go to &lt;<a class="reference external" href="http://www.geany.org/Download/Releases">http://www.geany.org/Download/Releases</a>&gt; and install the version of the &#8220;geany&#8221; editor appropriate for your system.</p>
</li>
<li><p class="first">If you wish to use &#8220;enhance_print&#8221; on windows -</p>
<blockquote>
<div><ol class="arabic simple">
<li>Go to &lt;<a class="reference external" href="https://github.com/adoxa/ansicon/downloads">https://github.com/adoxa/ansicon/downloads</a>&gt; and download &#8220;ansicon&#8221;</li>
<li>In the Edit -&gt; Preferences -&gt; Tools menu of &#8220;geany&#8221; enter into the Terminal input the full path of &#8220;ansicon.exe&#8221;</li>
</ol>
</div></blockquote>
</li>
</ol>
</div></blockquote>
<p>In addition to the code shown in the examples section of this document there are more examples in the Examples directory under the
<em>galgebra</em> directory.</p>
</div>
<div class="section" id="module-components">
<h2>Module Components<a class="headerlink" href="#module-components" title="Permalink to this headline">¶</a></h2>
<div class="section" id="instantiating-a-geometric-algebra">
<h3>Instantiating a Geometric Algebra<a class="headerlink" href="#instantiating-a-geometric-algebra" title="Permalink to this headline">¶</a></h3>
<p>A geometric algebra is instantiated with</p>
<blockquote>
<div><p><em>sympy.galgebra.GA(basis, g=None, coords=None, norm=False, debug=False, X=None)</em></p>
<p>The <em>basis</em> and <em>g</em> parameters were described in section <a class="reference internal" href="#vbm"><em>Vector Basis and Metric</em></a>.</p>
<p>If <em>debug=True</em> the data structure required to initialize the <em>Ga</em> class
are printed out.</p>
<p><em>coords</em> is a tuple of <em>sympy</em> symbols equal in length to
the number of basis vectors.  These symbols are used as the arguments of a
multivector field as a function of position and for calculating the derivatives
of a multivector field. Additionally, <em>Ga()</em> calculates the pseudo scalar,
<span class="math">\(I\)</span> and makes them available to the programmer as <em>MV.I</em> and <em>MV.Iinv</em>.
For the case of instantiating a 3-d geometeric algebra in spherical coordinates we could use</p>
<blockquote>
<div><div class="highlight-python"><div class="highlight"><pre><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">th</span><span class="p">,</span> <span class="n">phi</span><span class="p">)</span> <span class="o">=</span> <span class="n">coords</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;r,theta,phi&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">basis</span> <span class="o">=</span> <span class="s">&#39;e_r e_theta e_phi&#39;</span>
<span class="n">g</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">r</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">th</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">]</span>
<span class="n">sp3d</span> <span class="o">=</span> <span class="n">Ga</span><span class="p">(</span><span class="n">basis</span><span class="p">,</span><span class="n">g</span><span class="o">=</span><span class="n">g</span><span class="p">,</span><span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span><span class="n">norm</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>The input <span class="math">\(X\)</span> allows the metric to be input as a vector manifold. <span class="math">\(X\)</span>
is a list of functions of <em>coords</em> dimension, <span class="math">\(m\)</span>, equal to or greater than
the number of coordinates. If <em>g=None</em> it is assumed that <em>X</em> is a vector in an
<span class="math">\(m\)</span>-dimensional orthonormal Euclidian vector space.  If it is wished
the embedding vector space to be non-Euclidian that condition is specified with
<em>g</em>.  For example if we wish the embedding space to be a 5-dimensional Minkowski
space then <em>g=[-1,1,1,1,1]</em>.  Then the <em>Ga</em> class uses <em>X</em> to calculate the
manifold basis vectors as a function of the coordinates and from them the metric
tensor.</p>
<p>If <em>norm=True</em> the basis vectors of the manifold are normalized so that the
absolute values of the squares of the basis vectors are one. <cite>It is suggested
that one only use this option for diagonal metric tensors, and even there due so
with caution, due to the possible
problems with taking the square root of a general</cite> <em>sympy</em> <cite>expression (one that has an
unknown sign).</cite></p>
<p>In addition to the basis vectors, if coordinates are defined for the geometric algebra, the
left and right geometric derivative operators are calculated and accessed with the <em>Ga</em>
member function <em>grads()</em>.</p>
<p><em>Ga.grads()</em></p>
<blockquote>
<div><blockquote>
<div><em>Ga.grads()</em> returns a tuple with the left and right geometric derivative operators. A
typical usage would be</div></blockquote>
<div class="highlight-python"><div class="highlight"><pre><span class="p">(</span><span class="n">grad</span><span class="p">,</span><span class="n">rgrad</span><span class="p">)</span> <span class="o">=</span> <span class="n">sp3d</span><span class="o">.</span><span class="n">grads</span><span class="p">()</span>
</pre></div>
</div>
</div></blockquote>
<p>for the spherical 3-d geometric algebra. The left derivative <em>grad</em> <span class="math">\(= \nabla\)</span> and the
right derivative <em>rgrad</em> <span class="math">\(= \bar{\nabla}\)</span> have been explained in section <a class="reference internal" href="#dops"><em>Linear Differential Operators</em></a>. Again
the names <em>grad</em> and <em>rgrad</em> are whatever the user chooses them to be.</p>
<p>an alternative instantiation method is</p>
<p><em>Ga.build(basis, g=None, coords=None, X=None, norm=False, debug=False)</em></p>
<blockquote>
<div><p>The input parameters for <em>Ga.build()</em> are the same as for <em>Ga()</em>.  The difference is
that in addition to returning the geometric algebra <em>Ga.build()</em> returns the basis vectors
at the same time. Using <em>Ga.build()</em> in the previous example gives</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">th</span><span class="p">,</span> <span class="n">phi</span><span class="p">)</span> <span class="o">=</span> <span class="n">coords</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;r,theta,phi&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">basis</span> <span class="o">=</span> <span class="s">&#39;e_r e_theta e_phi&#39;</span>
<span class="n">g</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">r</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">th</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">]</span>
<span class="p">(</span><span class="n">sp3d</span><span class="p">,</span><span class="n">er</span><span class="p">,</span><span class="n">eth</span><span class="p">,</span><span class="n">ephi</span><span class="p">)</span> <span class="o">=</span> <span class="n">Ga</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="n">basis</span><span class="p">,</span><span class="n">g</span><span class="o">=</span><span class="n">g</span><span class="p">,</span><span class="n">coord</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span><span class="n">norm</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>To access the pseudo scalar of the geometric algebra us the member function <em>I()</em>.</p>
<p><em>Ga.I()</em></p>
<blockquote>
<div><em>Ga.I()</em> returns the normalized pseudo scalar (<span class="math">\(\left | {I^{2}}\right |=1\)</span>) for the
geometric algebra. For example <span class="math">\(I\)</span> = <em>o3d.I()</em> for the <em>o3d</em> geometric
algebra.</div></blockquote>
<p>In general we have defined member fuctions of the <em>Ga</em> class that will instantiate objects
of other classes since the objects of the other classes are all associated with a particular
geometric algebra object.  Thus we have</p>
<blockquote>
<div><a class="reference internal image-reference" href="_images/class_objs.png"><img alt="_images/class_objs.png" class="align-center" src="_images/class_objs.png" style="width: 400px;" /></a>
</div></blockquote>
<p>for the instantiation of various objects from the <em>Ga</em> class.  This means that in order to
instantiate any of these objects we need only to import <em>Ga</em> into our program.</p>
</div></blockquote>
</div>
<div class="section" id="instantiating-a-multivector">
<h3>Instantiating a Multivector<a class="headerlink" href="#instantiating-a-multivector" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>Since we need to associate each multivector with the geometric algebra that contains it
we use a member function of <em>Ga</em> to instantiate every multivector (There is a
multivector class, <em>Mv</em>, but in order the insure that every multivector is associated
with the correct geometric algebra we always use the member function <em>Ga.mv</em> to instantiate
the multivector.)  The multivector is instantiated with:</p>
<p><em>Ga.mv(name, mode, f=False)</em></p>
<blockquote>
<div><p>As an example of both instantiating a geometric algebra and multivectors consider the
following code fragment for a 3-d Euclidian geometric algebra.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span>
<span class="kn">from</span> <span class="nn">ga</span> <span class="kn">import</span> <span class="n">Ga</span>
<span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span> <span class="o">=</span> <span class="n">coords</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;x,y,z&#39;</span><span class="p">,</span><span class="n">real</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">o3d</span> <span class="o">=</span> <span class="n">Ga</span><span class="p">(</span><span class="s">&#39;e_x e_y e_z&#39;</span><span class="p">,</span> <span class="n">g</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">)</span>
<span class="p">(</span><span class="n">ex</span><span class="p">,</span> <span class="n">ey</span><span class="p">,</span> <span class="n">ez</span><span class="p">)</span> <span class="o">=</span> <span class="n">o3d</span><span class="o">.</span><span class="n">mv</span><span class="p">()</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">o3d</span><span class="o">.</span><span class="n">mv</span><span class="p">(</span><span class="s">&#39;V&#39;</span><span class="p">,</span><span class="s">&#39;vector&#39;</span><span class="p">,</span><span class="n">f</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>First consider the multivector instantiation <em>V = o3d.mv(&#8216;V&#8217;,&#8217;vector&#8217;,f=True)</em>.  Here
a 3-dimensional multivector field that is a function of <em>x</em>, <em>y</em>, and <em>z</em> (<em>f=True</em>) is
being instantiated.  If latex output were used (to be discussed later) the multivector
<em>V</em> would be displayed as</p>
<div class="math">
\[\begin{equation}
  A^{x}\boldsymbol{e}_{x} + A^{y}\boldsymbol{e}_{y} + A^{z}\boldsymbol{e}_{z}
\end{equation}\]</div><p>Where the coefficients of the basis vectors are generalized <em>sympy</em> functions of the
coordinates.  The superscripts (Denoted in text output by <em>A__x</em>, etc. so
that for text output <em>A</em> would be printed as <em>A__x*e_x+A__y*e_y+A__z*e_z</em>) are formed
from the coordinate symbols or if there are no coordinates from the subscripts of
the basis vectors.  The types of name and modes available for multivector instantiation are</p>
<blockquote>
<div><a class="reference internal image-reference" href="_images/instanciate_mv.png"><img alt="_images/instanciate_mv.png" class="align-center" src="_images/instanciate_mv.png" style="width: 750px;" /></a>
</div></blockquote>
<p>Line 5 of the previous listing illustrates the case of using the <em>mv</em> member function with
no arguments. The code does not return a multivector, but rather a tuple or the basis vectors of the geometric algebra <em>o3d</em>.
The elements of the tuple then can
be used to construct multivectors, or multivector fields through the operations
of addition, subtraction, multiplication (geometric, inner, and outer products and left and right contraction).
As an example we could construct the vector function</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">F</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">ex</span> <span class="o">+</span> <span class="n">z</span><span class="o">*</span><span class="n">ey</span> <span class="o">+</span> <span class="n">x</span><span class="o">*</span><span class="n">y</span><span class="o">*</span><span class="n">ez</span>
</pre></div>
</div>
<p>or the bivector function</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">B</span> <span class="o">=</span> <span class="n">z</span><span class="o">*</span><span class="p">(</span><span class="n">ex</span><span class="o">^</span><span class="n">ey</span><span class="p">)</span> <span class="o">+</span> <span class="n">y</span><span class="o">*</span><span class="p">(</span><span class="n">ey</span><span class="o">^</span><span class="n">ez</span><span class="p">)</span> <span class="o">+</span> <span class="n">y</span><span class="o">*</span><span class="p">(</span><span class="n">ex</span><span class="o">^</span><span class="n">ez</span><span class="p">)</span><span class="o">.</span>
</pre></div>
</div>
</div></blockquote>
<p>If one wished to calculate the left and right geometric derivatives of <em>F</em> and <em>B</em> the required code would be</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">(</span><span class="n">grad</span><span class="p">,</span><span class="n">rgrad</span><span class="p">)</span> <span class="o">=</span> <span class="n">o3d</span><span class="o">.</span><span class="n">grads</span><span class="p">()</span>
<span class="n">dF</span> <span class="o">=</span> <span class="n">grad</span><span class="o">*</span><span class="n">F</span>
<span class="n">dB</span> <span class="o">=</span> <span class="n">grad</span><span class="o">*</span><span class="n">B</span>
<span class="n">dFr</span> <span class="o">=</span> <span class="n">F</span><span class="o">*</span><span class="n">rgrad</span>
<span class="n">dBr</span> <span class="o">=</span> <span class="n">B</span><span class="o">*</span><span class="n">rgrad</span>
</pre></div>
</div>
<p><em>dF</em>, <em>dB</em>, <em>dFr</em>, and <em>dBr</em> are all multivector functions. For the code where the order of the operations are
reversed</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">(</span><span class="n">grad</span><span class="p">,</span><span class="n">rgrad</span><span class="p">)</span> <span class="o">=</span> <span class="n">o3d</span><span class="o">.</span><span class="n">grads</span><span class="p">()</span>
<span class="n">dFop</span> <span class="o">=</span> <span class="n">F</span><span class="o">*</span><span class="n">grad</span>
<span class="n">dBop</span> <span class="o">=</span> <span class="n">B</span><span class="o">*</span><span class="n">grad</span>
<span class="n">dFrop</span> <span class="o">=</span> <span class="n">rgrad</span><span class="o">*</span><span class="n">F</span>
<span class="n">dBrop</span> <span class="o">=</span> <span class="n">rgrad</span><span class="o">*</span><span class="n">B</span>
</pre></div>
</div>
<p><em>dFop</em>, <em>dBop</em>, <em>dFrop</em>, and <em>dBrop</em> are all multivector differential operators (again see section <a class="reference internal" href="#dops"><em>Linear Differential Operators</em></a>).</p>
</div></blockquote>
</div>
<div class="section" id="basic-multivector-class-functions">
<h3>Basic Multivector Class Functions<a class="headerlink" href="#basic-multivector-class-functions" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><em>convert_to_blades(self)</em></p>
<blockquote>
<div>Convert multivector from the base representation to the blade representation.
If multivector is already in blade representation nothing is done.</div></blockquote>
<p><em>convert_from_blades(self)</em></p>
<blockquote>
<div>Convert multivector from the blade representation to the base representation.
If multivector is already in base representation nothing is done.</div></blockquote>
<p><em>diff(self,var)</em></p>
<blockquote>
<div>Calculate derivative of each multivector coefficient with resepect to
variable <em>var</em> and form new multivector from coefficients.</div></blockquote>
<p><em>dual(self)</em></p>
<blockquote>
<div>Return dual of multivector which is multivector left multiplied by
pseudoscalar <em>Mv.i</em> (Hestenes,p22).</div></blockquote>
<p><em>even(self)</em></p>
<blockquote>
<div>Return the even grade components of the multivector.</div></blockquote>
<p><em>exp(self,hint=&#8217;+&#8217;)</em></p>
<blockquote>
<div><p>Return exponential of a multivector <span class="math">\(A\)</span> if <span class="math">\(A^{2}\)</span> is a scalar (if <span class="math">\(A^{2}\)</span> is not a scalar an
error message is generated).  If <span class="math">\(A\)</span> is the multivector then <span class="math">\(\boldsymbol{e}^{A}\)</span> is returned
where the default <em>hint</em>, <em>+</em>, assumes <span class="math">\(A^{2} &gt; 0\)</span> so that</p>
<div class="math">
\[  \begin{equation}
          \boldsymbol{e}^{A} = \cosh\sqrt{A^{2}}+\sinh\sqrt{A^{2}}\left (\frac{A}{\sqrt{A^{2}}}\right )
  \end{equation}\]</div><p>If the mode is not <em>+</em> then <span class="math">\(A^{2} &lt; 0\)</span> is assumed so that</p>
<div class="math">
\[  \begin{equation}
          \boldsymbol{e}^{A} = \cos \sqrt{-A^{2}}+\sin\sqrt{-A^{2}}\left (\frac{A}{\sqrt{-A^{2}}}\right ).
  \end{equation}\]</div><p>The hint is required for symbolic multivectors <span class="math">\(A\)</span> since in general <em>sympy</em> cannot determine if
<span class="math">\(A^{2}\)</span> is positive or negative.  If <span class="math">\(A\)</span> is purely numeric the hint is ignored.</p>
</div></blockquote>
<p><em>expand(self)</em></p>
<blockquote>
<div>Return multivector in which each coefficient has been expanded using
sympy <em>expand()</em> function.</div></blockquote>
<p><em>factor(self)</em></p>
<blockquote>
<div>Apply the sympy <em>factor</em> function to each coefficient of the multivector.</div></blockquote>
<p><em>Fmt(self, fmt=1,title=None)</em></p>
<blockquote>
<div><p>Function to print multivectors in different formats where</p>
<blockquote>
<div><a class="reference internal image-reference" href="_images/fmt_opts.png"><img alt="_images/fmt_opts.png" class="align-center" src="_images/fmt_opts.png" style="width: 400px;" /></a>
</div></blockquote>
<p><em>title</em> appends a title string to the beginning of the output.  An equal sign in
the title string is not required, but is added as a default.</p>
</div></blockquote>
<p><em>func(self,fct)</em></p>
<blockquote>
<div>Apply the <em>sympy</em> scalar function <em>fct</em> to each coefficient of the multivector.</div></blockquote>
<p><em>grade(self,igrade=0)</em></p>
<blockquote>
<div>Return a multivector that consists of the part of the multivector of
grade equal to <em>igrade</em>.  If the multivector has no <em>igrade</em> part
return a zero multivector.</div></blockquote>
<p><em>inv(self)</em></p>
<blockquote>
<div>Return the inverse of the multivector <span class="math">\(M\)</span> (<em>M.inv()</em>) if <span class="math">\(MM^{\dagger}\)</span> is a nonzero
scalar.  If <span class="math">\(MM^{\dagger}\)</span>
is not a scalar the program exits with an error message.</div></blockquote>
<p><em>norm(self)</em></p>
<blockquote>
<div>Return the norm of the multivector <span class="math">\(M\)</span> (<em>M.norm()</em>) defined by <span class="math">\(\sqrt{MM^{\dagger}}\)</span> if
<span class="math">\(MM^{\dagger}\)</span> is a
scalar (a sympy scalar
is returned).  If <span class="math">\(MM^{\dagger}\)</span> is not a scalar the program exits with an error message.</div></blockquote>
<p><em>norm2(self)</em></p>
<blockquote>
<div>Return the square of the norm of the multivector <span class="math">\(M\)</span> (<em>M.norm2()</em>) defined by <span class="math">\(MM^{\dagger}\)</span>
if <span class="math">\(MM^{\dagger}\)</span>
is a scalar (a sympy scalar
is returned).  If <span class="math">\(MM^{\dagger}\)</span> is not a scalar the program exits with an error message.</div></blockquote>
<p><em>proj(self,bases_lst)</em></p>
<blockquote>
<div>Return the projection of the multivector <span class="math">\(M\)</span> (<em>M.proj(bases_lst)</em>) onto the subspace defined by the list of bases
(<em>bases_lst</em>).</div></blockquote>
<p><em>scalar(self)</em></p>
<blockquote>
<div>Return the coefficient (sympy scalar) of the scalar part of a
multivector.</div></blockquote>
<p><em>simplify(self,mode=simplify)</em></p>
<blockquote>
<div><p><em>mode</em> is a sympy simplification function of a list/tuple of sympy
simplification functions that are applied in sequence (if more than
one function) each coefficient of the multivector.  For example if
we wished to applied <em>trigsimp</em> and <em>ratsimp</em> sympy functions to the
mulitvector <em>F</em> the code would be</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">Fsimp</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="p">[</span><span class="n">trigsimp</span><span class="p">,</span><span class="n">ratsimp</span><span class="p">])</span><span class="o">.</span>
</pre></div>
</div>
<p>Actually <em>simplify</em> could be used to apply any scalar sympy function to
the coefficients of the multivector.</p>
</div></blockquote>
<p><em>subs(self,x)</em></p>
<blockquote>
<div>Return multivector where sympy <em>subs</em> function has been applied to each
coefficient of multivector for argument dictionary/list <em>x</em>.</div></blockquote>
<p><em>rev(self)</em></p>
<blockquote>
<div>Return the reverse of the multivector.</div></blockquote>
<p><em>set_coef(self,grade,base,value)</em></p>
<blockquote>
<div>Set the multivector coefficient of index <em>(grade,base)</em> to <em>value</em>.</div></blockquote>
<p><em>trigsimp(self,**kwargs)</em></p>
<blockquote>
<div>Apply the sympy trignometric simplification function <em>trigsimp</em> to
each coefficient of the multivector. <em>**kwargs</em> are the arguments of
<em>trigsimp</em>.  See sympy documentation on <em>trigsimp</em> for more information.</div></blockquote>
</div></blockquote>
</div>
<div class="section" id="basic-multivector-functions">
<h3>Basic Multivector Functions<a class="headerlink" href="#basic-multivector-functions" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p><em>Com(A,B)</em></p>
<blockquote>
<div>Calulate commutator of multivectors <em>A</em> and <em>B</em>.  Returns <em>(AB-BA)/2</em>.</div></blockquote>
<p><em>GAeval(s,pstr=False)</em></p>
<blockquote>
<div>Returns multivector expression for string <em>s</em> with operator precedence for
string <em>s</em> defined by inputs to function <em>def_prec()</em>.  if <em>pstr=True</em>
<em>s</em> and <em>s</em> with parenthesis added to enforce operator precedence are printed.</div></blockquote>
<p><em>Nga(x,prec=5)</em></p>
<blockquote>
<div>If <em>x</em> is a multivector with coefficients that contain floating point numbers, <em>Nga()</em>
rounds all these numbers to a precision of <em>prec</em> and returns the rounded multivector.</div></blockquote>
<p><em>ReciprocalFrame(basis,mode=&#8217;norm&#8217;)</em></p>
<blockquote>
<div>If <em>basis</em> is a list/tuple of vectors, <em>ReciprocalFrame()</em> returns a tuple of reciprocal
vectors.  If <em>mode=norm</em> the vectors are normalized.  If <em>mode</em> is anything other than
<em>norm</em> the vectors are unnormalized and the normalization coefficient is added to the
end of the tuple.  One must divide by the coefficient to normalize the vectors.</div></blockquote>
<p><em>ScalarFunction(TheFunction)</em></p>
<blockquote>
<div>If <em>TheFuction</em> is a real <em>sympy</em> fuction a scalar multivector function is returned.</div></blockquote>
<p><em>cross(v1,v2)</em></p>
<blockquote>
<div>If <em>v1</em> and <em>v2</em> are 3-dimensional euclidian vectors the vector cross product is
returned, <span class="math">\(v_{1}\times v_{2} = -I\left ( v_{1}\wedge v_{2} \right )\)</span>.</div></blockquote>
<p><em>def_prec(gd,op_ord=&#8217;&lt;&gt;|,^,*&#8217;)</em></p>
<blockquote>
<div>This is used with the <em>GAeval()</em> function to evaluate a string representing a multivector
expression with a revised operator precedence.  <em>def_prec()</em> redefines the operator
precedence for multivectors. <em>def_prec()</em> must be called in the main program an the
argument <em>gd</em> must be <em>globals()</em>.  The argument <em>op_ord</em> defines the order of operator
precedence from high to low with groups of equal precedence separated by commas. the default
precedence <em>op_ord=&#8217;&lt;&gt;|,^,*&#8217;</em> is that used by Hestenes.</div></blockquote>
<p><em>dual(M)</em></p>
<blockquote>
<div>Return the dual of the multivector <em>M</em>, math:<cite>MI^{-1}</cite>.</div></blockquote>
<p><em>inv(B)</em></p>
<blockquote>
<div>If for the multivector <span class="math">\(B\)</span>, <span class="math">\(BB^{\dagger}\)</span> is a nonzero scalar, return
<span class="math">\(B^{-1} = B^{\dagger}/(BB^{\dagger})\)</span>.</div></blockquote>
<p><em>proj(B,A)</em></p>
<blockquote>
<div>Project blade <em>A</em> on blade <em>B</em> returning <span class="math">\(\left ( A\lfloor B\right ) B^{-1}\)</span>.</div></blockquote>
<p><em>refl(B,A)</em></p>
<blockquote>
<div>Reflect blade <em>A</em> in blade <em>B</em>. If <em>r</em> is grade of <em>A</em> and <em>s</em> is grade of <em>B</em>
returns <span class="math">\((-1)^{s(r+1)}BAB^{-1}\)</span>.</div></blockquote>
<p><em>rot(itheta,A)</em></p>
<blockquote>
<div>Rotate blade <em>A</em> by 2-blade <em>itheta</em>.  Is is assumed that <em>itheta*itheta &gt; 0</em> so that
the rotation is Euclidian and not hyperbolic so that the angle of
rotation is <em>theta = itheta.norm()</em>.  Ther in 3-dimensional Euclidian space. <em>theta</em> is the angle of rotation (scalar in radians) and
<em>n</em> is the vector axis of rotation.  Returned is the rotor <em>cos(theta)+sin(theta)*N</em> where <em>N</em> is
the normalized dual of <em>n</em>.</div></blockquote>
</div></blockquote>
</div>
<div class="section" id="multivector-derivatives">
<h3>Multivector Derivatives<a class="headerlink" href="#multivector-derivatives" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>The various derivatives of a multivector function is accomplished by
multiplying the gradient operator vector with the function.  The gradiant
operation vector is returned by the <em>Ga.mv()</em> function if coordinates
are defined.  For example if we have for a 3-D vector space</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">X</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">)</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;x y z&#39;</span><span class="p">)</span>
<span class="n">o3d</span> <span class="o">=</span> <span class="n">Ga</span><span class="p">(</span><span class="s">&#39;e*x|y|z&#39;</span><span class="p">,</span><span class="n">metric</span><span class="o">=</span><span class="s">&#39;[1,1,1]&#39;</span><span class="p">,</span><span class="n">coords</span><span class="o">=</span><span class="n">X</span><span class="p">)</span>
<span class="p">(</span><span class="n">ex</span><span class="p">,</span><span class="n">ey</span><span class="p">,</span><span class="n">ez</span><span class="p">)</span> <span class="o">=</span> <span class="n">o3d</span><span class="o">.</span><span class="n">mv</span><span class="p">()</span>
<span class="p">(</span><span class="n">grad</span><span class="p">,</span><span class="n">rgrad</span><span class="p">)</span> <span class="o">=</span> <span class="n">o3d</span><span class="o">.</span><span class="n">grads</span><span class="p">()</span>
</pre></div>
</div>
<p>Then the gradient operator vector is <em>grad</em> (actually the user can give
it any name he wants to).  Then the derivatives of the multivector
function <em>F = o3d.mv(&#8216;F&#8217;,&#8217;mv&#8217;,f=True)</em> are given by multiplying by the
left geometric derivative operator and the right geometric derivative operator
<em>grad</em> <span class="math">\(= \nabla\)</span> and <em>rgrad</em> <span class="math">\(= \bar{\nabla}\)</span>.  Another option
is to use the gradiant operator members of the geometric algebra directly where we have
<span class="math">\(\nabla =\)</span> <em>o3d.grad</em> and <span class="math">\(\bar{\nabla} =\)</span> <em>o3d.rgrad</em>.</p>
<div class="math">
\[\begin{align*}
      \nabla F &=  \mbox{grad $*$ F} \\
      F \bar{\nabla} &=  \mbox{F $*$ rgrad} \\
      \nabla \wedge F &=  \mbox{grad ^ F} \\
      F \wedge \bar{\nabla} &=  \mbox{F ^ rgrad} \\
      \nabla \cdot F &=  \mbox{grad $|$ F} \\
      F \cdot \bar{\nabla} &=  \mbox{F $|$ rgrad} \\
      \nabla \lfloor F &=  \mbox{grad $<$ F} \\
      F \lfloor \bar{\nabla} &=  \mbox{F $<$ rgrad} \\
      \nabla \rfloor F &=  \mbox{grad $>$ F} \\
      F \rfloor \bar{\nabla} &= \mbox{F $>$ rgrad}
\end{align*}\]</div><p>The preceding code block gives examples of all possible multivector
derivatives of the multivector function <em>F</em> where the operation returns
a multivector function. The complementary operations</p>
<blockquote>
<div><div class="math">
\[\begin{align*}
      F \nabla &=  \mbox{F $*$ grad} \\
      \bar{\nabla} F &=  \mbox{rgrad $*$ F} \\
      F \wedge \nabla &=  \mbox{F ^ grad} \\
      \bar{\nabla} \wedge F &=  \mbox{rgrad ^ F} \\
      F \cdot \nabla &=  \mbox{F $|$ grad} \\
      \bar{\nabla}\cdot F &=  \mbox{rgrad $|$ F} \\
      F \lfloor \nabla &=  \mbox{F $<$ grad} \\
      \bar{\nabla} \lfloor F &=  \mbox{rgrad $<$ F} \\
      F \rfloor \nabla &=  \mbox{F $>$ grad} \\
      \bar{\nabla} \rfloor F &= \mbox{rgrad $>$ F}
\end{align*}\]</div></div></blockquote>
<p>all return multivector linear differential operators.</p>
</div></blockquote>
</div>
<div class="section" id="submanifolds">
<h3>Submanifolds<a class="headerlink" href="#submanifolds" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>In general the geometric algebra that the user defines exists on the tangent space of
a manifold.  The submanifold class, <em>Sm</em>, is derived from
the <em>Ga</em> class and allows one
to define a submanifold of a manifold by defining a coordinate mapping between the submanifold
coordinates and the manifold coordinates.  What is returned as the submanifold is the geometric
algebra of the tangent space of the submanifold. The submanifold for a geometric algebra is
instantiated with</p>
<p><em>Ga.sm(map,coords,root=&#8217;e&#8217;,norm=False)</em></p>
<blockquote>
<div><p>To define the submanifold we must define a coordinate map from the coordinates of the submanifold to
each of the coordinates of the base manifold.  Thus the arguments <em>map</em> and <em>coords</em> are
respectively lists of functions and symbols.  The list of symbols, <em>coords</em>, are the coordinates of the
submanifold and are of length equal to the dimension of the submanifold.  The list of functions, <em>map</em>,
define the mapping from the coordinate space of the submanifold to the coordinate space of the
base manifold.  The length of <em>map</em> is equal to the dimension of the base manifold and each function in
<em>map</em> is a function of the coordinates of the submanifold. As a concrete example consider the
following code.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">latex</span>
<span class="kn">from</span> <span class="nn">ga</span> <span class="kn">import</span> <span class="n">Ga</span>
<span class="kn">from</span> <span class="nn">printer</span> <span class="kn">import</span> <span class="n">Format</span><span class="p">,</span> <span class="n">xpdf</span>

<span class="n">Format</span><span class="p">()</span>
<span class="n">coords</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">th</span><span class="p">,</span> <span class="n">phi</span><span class="p">)</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;r,theta,phi&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">sp3d</span> <span class="o">=</span> <span class="n">Ga</span><span class="p">(</span><span class="s">&#39;e_r e_th e_ph&#39;</span><span class="p">,</span> <span class="n">g</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">r</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">th</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">],</span> <span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="n">sph_uv</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;u,v&#39;</span><span class="p">,</span> <span class="n">real</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">sph_map</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">]</span>  <span class="c"># Coordinate map for sphere of r = 1</span>
<span class="n">sph2d</span> <span class="o">=</span> <span class="n">sp3d</span><span class="o">.</span><span class="n">sm</span><span class="p">(</span><span class="n">sph_map</span><span class="p">,</span><span class="n">sph_uv</span><span class="p">)</span>

<span class="k">print</span> <span class="s">r&#39;(u,v)\rightarrow (r,\theta,\phi) = &#39;</span><span class="p">,</span><span class="n">latex</span><span class="p">(</span><span class="n">sph_map</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&#39;g =&#39;</span><span class="p">,</span><span class="n">latex</span><span class="p">(</span><span class="n">sph2d</span><span class="o">.</span><span class="n">g</span><span class="p">)</span>
<span class="n">F</span> <span class="o">=</span> <span class="n">sph2d</span><span class="o">.</span><span class="n">mv</span><span class="p">(</span><span class="s">&#39;F&#39;</span><span class="p">,</span><span class="s">&#39;vector&#39;</span><span class="p">,</span><span class="n">f</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="c">#scalar function</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">sph2d</span><span class="o">.</span><span class="n">mv</span><span class="p">(</span><span class="s">&#39;f&#39;</span><span class="p">,</span><span class="s">&#39;scalar&#39;</span><span class="p">,</span><span class="n">f</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="c">#vector function</span>
<span class="k">print</span> <span class="s">r&#39;\nabla f =&#39;</span><span class="p">,</span><span class="n">sph2d</span><span class="o">.</span><span class="n">grad</span> <span class="o">*</span> <span class="n">f</span>
<span class="k">print</span> <span class="s">&#39;F =&#39;</span><span class="p">,</span><span class="n">F</span>
<span class="k">print</span> <span class="s">r&#39;\nabla F = &#39;</span><span class="p">,</span><span class="n">sph2d</span><span class="o">.</span><span class="n">grad</span> <span class="o">*</span> <span class="n">F</span>

<span class="n">cir_s</span> <span class="o">=</span> <span class="n">s</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;s&#39;</span><span class="p">,</span><span class="n">real</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">cir_map</span> <span class="o">=</span> <span class="p">[</span><span class="n">pi</span><span class="o">/</span><span class="mi">8</span><span class="p">,</span><span class="n">s</span><span class="p">]</span>
<span class="n">cir1d</span> <span class="o">=</span> <span class="n">sph2d</span><span class="o">.</span><span class="n">sm</span><span class="p">(</span><span class="n">cir_map</span><span class="p">,(</span><span class="n">cir_s</span><span class="p">,))</span>

<span class="k">print</span> <span class="s">&#39;g =&#39;</span><span class="p">,</span><span class="n">latex</span><span class="p">(</span><span class="n">cir1d</span><span class="o">.</span><span class="n">g</span><span class="p">)</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">cir1d</span><span class="o">.</span><span class="n">mv</span><span class="p">(</span><span class="s">&#39;h&#39;</span><span class="p">,</span><span class="s">&#39;scalar&#39;</span><span class="p">,</span><span class="n">f</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">H</span> <span class="o">=</span> <span class="n">cir1d</span><span class="o">.</span><span class="n">mv</span><span class="p">(</span><span class="s">&#39;H&#39;</span><span class="p">,</span><span class="s">&#39;vector&#39;</span><span class="p">,</span><span class="n">f</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="k">print</span> <span class="s">r&#39;(s)\rightarrow (u,v) = &#39;</span><span class="p">,</span><span class="n">latex</span><span class="p">(</span><span class="n">cir_map</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&#39;H =&#39;</span><span class="p">,</span> <span class="n">H</span>
<span class="k">print</span> <span class="n">latex</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
<span class="k">print</span> <span class="s">r&#39;\nabla h =&#39;</span><span class="p">,</span> <span class="n">cir1d</span><span class="o">.</span><span class="n">grad</span> <span class="o">*</span> <span class="n">h</span>
<span class="k">print</span> <span class="s">r&#39;\nabla H =&#39;</span><span class="p">,</span> <span class="n">cir1d</span><span class="o">.</span><span class="n">grad</span> <span class="o">*</span> <span class="n">H</span>
<span class="n">xpdf</span><span class="p">(</span><span class="n">crop</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">png</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>The program output is</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="_images/manifold_src.png"><img alt="_images/manifold_src.png" src="_images/manifold_src.png" style="width: 350px;" /></a>
</div>
<p>The base manifold, <em>sp3d</em>, is a 3-d Euclidian space using standard spherical coordinates. The submanifold
<em>sph2d</em> of <em>sp3d</em> is a spherical surface of radius <span class="math">\(1\)</span>.  To take the sumanifold operation one step further
the submanifold <em>cir1d</em> of <em>sph2d</em> is a circle in <em>sph2d</em> where the latitude of the circle is <span class="math">\(\pi/8\)</span>.</p>
<p>In each case, for demonstration purposes, a scalar and vector function on each manifold is defined (<em>f</em> and <em>F</em>
for the 2-d manifold and <em>h</em> and <em>H</em> for the 1-d manifold) and the geometric derivative of each function is taken.  The
manifold mapping and the metric tensor for <em>cir1d</em> of <em>sph2d</em> are also shown. Note that if the submanifold
basis vectors are not normalized the program output is.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="_images/man_unnorm.png"><img alt="_images/man_unnorm.png" src="_images/man_unnorm.png" style="width: 500px;" /></a>
</div>
</div></blockquote>
</div></blockquote>
</div>
<div class="section" id="id10">
<h3>Linear Transformations<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>The mathematical background for linear transformations is in section <a class="reference internal" href="#ltrans"><em>Linear Transformations</em></a>.  Linear transformations on the tangent space of
the manifold are instantiated with the <em>Ga</em> member function <em>lt</em> (the actual class being instantiated is <em>Lt</em>) as shown in
lines 12, 20, 26, and 44 of the code (Ltrans.py)</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">latex</span>
<span class="kn">from</span> <span class="nn">ga</span> <span class="kn">import</span> <span class="n">Ga</span>
<span class="kn">from</span> <span class="nn">printer</span> <span class="kn">import</span> <span class="n">Format</span><span class="p">,</span> <span class="n">xpdf</span>

<span class="n">Format</span><span class="p">()</span>
<span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span> <span class="o">=</span> <span class="n">xyz</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;x,y,z&#39;</span><span class="p">,</span><span class="n">real</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="p">(</span><span class="n">o3d</span><span class="p">,</span> <span class="n">ex</span><span class="p">,</span> <span class="n">ey</span><span class="p">,</span> <span class="n">ez</span><span class="p">)</span> <span class="o">=</span> <span class="n">Ga</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="s">&#39;e_x e_y e_z&#39;</span><span class="p">,</span> <span class="n">g</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">coords</span><span class="o">=</span><span class="n">xyz</span><span class="p">)</span>
<span class="n">grad</span> <span class="o">=</span> <span class="n">o3d</span><span class="o">.</span><span class="n">grad</span>
<span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">=</span> <span class="n">uv</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;u,v&#39;</span><span class="p">,</span><span class="n">real</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="p">(</span><span class="n">g2d</span><span class="p">,</span> <span class="n">eu</span><span class="p">,</span> <span class="n">ev</span><span class="p">)</span> <span class="o">=</span> <span class="n">Ga</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="s">&#39;e_u e_v&#39;</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">uv</span><span class="p">)</span>
<span class="n">grad_uv</span> <span class="o">=</span> <span class="n">g2d</span><span class="o">.</span><span class="n">grad</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">o3d</span><span class="o">.</span><span class="n">lt</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&#39;#3d orthogonal ($A,</span><span class="se">\\</span><span class="s">;B$ are linear transformations)&#39;</span>
<span class="k">print</span> <span class="s">&#39;A =&#39;</span><span class="p">,</span> <span class="n">A</span>
<span class="k">print</span> <span class="s">r&#39;\f{\operatorname{mat}}{A} =&#39;</span><span class="p">,</span> <span class="n">latex</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">matrix</span><span class="p">())</span>
<span class="k">print</span> <span class="s">&#39;</span><span class="se">\\</span><span class="s">f{</span><span class="se">\\</span><span class="s">det}{A} =&#39;</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">det</span><span class="p">()</span>
<span class="k">print</span> <span class="s">&#39;</span><span class="se">\\</span><span class="s">overline{A} =&#39;</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">adj</span><span class="p">()</span>
<span class="k">print</span> <span class="s">&#39;</span><span class="se">\\</span><span class="s">f{</span><span class="se">\\</span><span class="s">Tr}{A} =&#39;</span><span class="p">,</span> <span class="n">A</span><span class="o">.</span><span class="n">tr</span><span class="p">()</span>
<span class="k">print</span> <span class="s">&#39;</span><span class="se">\\</span><span class="s">f{A}{e_x^e_y} =&#39;</span><span class="p">,</span> <span class="n">A</span><span class="p">(</span><span class="n">ex</span><span class="o">^</span><span class="n">ey</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&#39;</span><span class="se">\\</span><span class="s">f{A}{e_x}^</span><span class="se">\\</span><span class="s">f{A}{e_y} =&#39;</span><span class="p">,</span> <span class="n">A</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span><span class="o">^</span><span class="n">A</span><span class="p">(</span><span class="n">ey</span><span class="p">)</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">o3d</span><span class="o">.</span><span class="n">lt</span><span class="p">(</span><span class="s">&#39;B&#39;</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&#39;A + B =&#39;</span><span class="p">,</span> <span class="n">A</span> <span class="o">+</span> <span class="n">B</span>
<span class="k">print</span> <span class="s">&#39;AB =&#39;</span><span class="p">,</span> <span class="n">A</span> <span class="o">*</span> <span class="n">B</span>
<span class="k">print</span> <span class="s">&#39;A - B =&#39;</span><span class="p">,</span> <span class="n">A</span> <span class="o">-</span> <span class="n">B</span>

<span class="k">print</span> <span class="s">&#39;#2d general ($A,</span><span class="se">\\</span><span class="s">;B$ are linear transformations)&#39;</span>
<span class="n">A2d</span> <span class="o">=</span> <span class="n">g2d</span><span class="o">.</span><span class="n">lt</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&#39;A =&#39;</span><span class="p">,</span> <span class="n">A2d</span>
<span class="k">print</span> <span class="s">&#39;</span><span class="se">\\</span><span class="s">f{</span><span class="se">\\</span><span class="s">det}{A} =&#39;</span><span class="p">,</span> <span class="n">A2d</span><span class="o">.</span><span class="n">det</span><span class="p">()</span>
<span class="c">#A2d.adj().Fmt(4,&#39;\\overline{A}&#39;)</span>
<span class="k">print</span> <span class="s">&#39;</span><span class="se">\\</span><span class="s">f{</span><span class="se">\\</span><span class="s">Tr}{A} =&#39;</span><span class="p">,</span> <span class="n">A2d</span><span class="o">.</span><span class="n">tr</span><span class="p">()</span>
<span class="k">print</span> <span class="s">&#39;</span><span class="se">\\</span><span class="s">f{A}{e_u^e_v} =&#39;</span><span class="p">,</span> <span class="n">A2d</span><span class="p">(</span><span class="n">eu</span><span class="o">^</span><span class="n">ev</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&#39;</span><span class="se">\\</span><span class="s">f{A}{e_u}^</span><span class="se">\\</span><span class="s">f{A}{e_v} =&#39;</span><span class="p">,</span> <span class="n">A2d</span><span class="p">(</span><span class="n">eu</span><span class="p">)</span><span class="o">^</span><span class="n">A2d</span><span class="p">(</span><span class="n">ev</span><span class="p">)</span>
<span class="n">B2d</span> <span class="o">=</span> <span class="n">g2d</span><span class="o">.</span><span class="n">lt</span><span class="p">(</span><span class="s">&#39;B&#39;</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&#39;B =&#39;</span><span class="p">,</span> <span class="n">B2d</span>
<span class="k">print</span> <span class="s">&#39;A + B =&#39;</span><span class="p">,</span> <span class="n">A2d</span> <span class="o">+</span> <span class="n">B2d</span>
<span class="k">print</span> <span class="s">&#39;AB =&#39;</span><span class="p">,</span> <span class="n">A2d</span> <span class="o">*</span> <span class="n">B2d</span>
<span class="k">print</span> <span class="s">&#39;A - B =&#39;</span><span class="p">,</span> <span class="n">A2d</span> <span class="o">-</span> <span class="n">B2d</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">g2d</span><span class="o">.</span><span class="n">mv</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">,</span><span class="s">&#39;vector&#39;</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">g2d</span><span class="o">.</span><span class="n">mv</span><span class="p">(</span><span class="s">&#39;b&#39;</span><span class="p">,</span><span class="s">&#39;vector&#39;</span><span class="p">)</span>
<span class="k">print</span> <span class="s">r&#39;a|\f{\overline{A}}{b}-b|\f{\underline{A}}{a} =&#39;</span><span class="p">,((</span><span class="n">a</span><span class="o">|</span><span class="n">A2d</span><span class="o">.</span><span class="n">adj</span><span class="p">()(</span><span class="n">b</span><span class="p">))</span><span class="o">-</span><span class="p">(</span><span class="n">b</span><span class="o">|</span><span class="n">A2d</span><span class="p">(</span><span class="n">a</span><span class="p">)))</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>

<span class="k">print</span> <span class="s">&#39;#4d Minkowski spaqce (Space Time)&#39;</span>
<span class="n">m4d</span> <span class="o">=</span> <span class="n">Ga</span><span class="p">(</span><span class="s">&#39;e_t e_x e_y e_z&#39;</span><span class="p">,</span> <span class="n">g</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">coords</span><span class="o">=</span><span class="n">symbols</span><span class="p">(</span><span class="s">&#39;t,x,y,z&#39;</span><span class="p">,</span><span class="n">real</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
<span class="n">T</span> <span class="o">=</span> <span class="n">m4d</span><span class="o">.</span><span class="n">lt</span><span class="p">(</span><span class="s">&#39;T&#39;</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&#39;g =&#39;</span><span class="p">,</span> <span class="n">m4d</span><span class="o">.</span><span class="n">g</span>
<span class="k">print</span> <span class="s">r&#39;\underline{T} =&#39;</span><span class="p">,</span><span class="n">T</span>
<span class="k">print</span> <span class="s">r&#39;\overline{T} =&#39;</span><span class="p">,</span><span class="n">T</span><span class="o">.</span><span class="n">adj</span><span class="p">()</span>
<span class="c">#m4d.mv(T.det()).Fmt(4,r&#39;\f{\det}{\underline{T}}&#39;)</span>
<span class="k">print</span> <span class="s">r&#39;\f{\mbox{tr}}{\underline{T}} =&#39;</span><span class="p">,</span><span class="n">T</span><span class="o">.</span><span class="n">tr</span><span class="p">()</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">m4d</span><span class="o">.</span><span class="n">mv</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">,</span><span class="s">&#39;vector&#39;</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">m4d</span><span class="o">.</span><span class="n">mv</span><span class="p">(</span><span class="s">&#39;b&#39;</span><span class="p">,</span><span class="s">&#39;vector&#39;</span><span class="p">)</span>
<span class="k">print</span> <span class="s">r&#39;a|\f{\overline{T}}{b}-b|\f{\underline{T}}{a} =&#39;</span><span class="p">,((</span><span class="n">a</span><span class="o">|</span><span class="n">T</span><span class="o">.</span><span class="n">adj</span><span class="p">()(</span><span class="n">b</span><span class="p">))</span><span class="o">-</span><span class="p">(</span><span class="n">b</span><span class="o">|</span><span class="n">T</span><span class="p">(</span><span class="n">a</span><span class="p">)))</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
<span class="n">xpdf</span><span class="p">(</span><span class="n">paper</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">12</span><span class="p">),</span><span class="n">crop</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">png</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>In all of the examples in the above code the default instantiation is used which produces a general (all the
coefficients of the linear transformation are symbolic constants) linear transformation. Note that to
instantiate linear transformations
coordinates, <span class="math">\(\left \{\boldsymbol{e}_{i} \right \}\)</span>, must be defined when the geometric algebra associated with the
linear transformation is instantiated.
This is due to the naming conventions of the general linear transformation (coordinate names are used)
and for the calculation
of the trace of the linear transformation which requires taking a divergence.
To instantiate a specific linear transformation
the usage of <em>lt()</em> is  <em>Ga.lt(M,f=False)</em>.</p>
<p><em>M</em> is an expression that can define the coefficients of the linear transformation in various ways
defined as follows.</p>
<a class="reference internal image-reference" href="_images/lt_ops.png"><img alt="_images/lt_ops.png" class="align-center" src="_images/lt_ops.png" style="width: 800px;" /></a>
<p><em>f</em> is <em>True</em> or <em>False</em>. If <em>True</em> the symbolic coefficients of the general linear transformation are
instantiated as functions of the coordinates.</p>
<p>The different methods of instantiation are demonstrated in the code (<em>LtransInst.py</em>)</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">latex</span><span class="p">,</span> <span class="n">Matrix</span>
<span class="kn">from</span> <span class="nn">ga</span> <span class="kn">import</span> <span class="n">Ga</span>
<span class="kn">from</span> <span class="nn">printer</span> <span class="kn">import</span> <span class="n">Format</span><span class="p">,</span> <span class="n">xpdf</span>

<span class="n">Format</span><span class="p">()</span>
<span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span> <span class="o">=</span> <span class="n">xyz</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;x,y,z&#39;</span><span class="p">,</span><span class="n">real</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="p">(</span><span class="n">o3d</span><span class="p">,</span> <span class="n">ex</span><span class="p">,</span> <span class="n">ey</span><span class="p">,</span> <span class="n">ez</span><span class="p">)</span> <span class="o">=</span> <span class="n">Ga</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="s">&#39;e_x e_y e_z&#39;</span><span class="p">,</span> <span class="n">g</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">coords</span><span class="o">=</span><span class="n">xyz</span><span class="p">)</span>

<span class="n">A</span> <span class="o">=</span> <span class="n">o3d</span><span class="o">.</span><span class="n">lt</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">)</span>
<span class="k">print</span> <span class="s">r&#39;\mbox{General Instantiation: }A =&#39;</span><span class="p">,</span> <span class="n">A</span>
<span class="n">th</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;theta&#39;</span><span class="p">,</span><span class="n">real</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">R</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="n">th</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="n">ex</span><span class="o">^</span><span class="n">ey</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">th</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">o3d</span><span class="o">.</span><span class="n">lt</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
<span class="k">print</span> <span class="s">r&#39;\mbox{Rotor: }R =&#39;</span><span class="p">,</span> <span class="n">R</span>
<span class="k">print</span> <span class="s">r&#39;\mbox{Rotor Instantiation: }B =&#39;</span><span class="p">,</span> <span class="n">B</span>
<span class="n">dict1</span> <span class="o">=</span> <span class="p">{</span><span class="n">ex</span><span class="p">:</span><span class="n">ey</span><span class="o">+</span><span class="n">ez</span><span class="p">,</span><span class="n">ez</span><span class="p">:</span><span class="n">ey</span><span class="o">+</span><span class="n">ez</span><span class="p">,</span><span class="n">ey</span><span class="p">:</span><span class="n">ex</span><span class="o">+</span><span class="n">ez</span><span class="p">}</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">o3d</span><span class="o">.</span><span class="n">lt</span><span class="p">(</span><span class="n">dict1</span><span class="p">)</span>
<span class="k">print</span> <span class="s">r&#39;\mbox{Dictionary} =&#39;</span><span class="p">,</span> <span class="n">latex</span><span class="p">(</span><span class="n">dict1</span><span class="p">)</span>
<span class="k">print</span> <span class="s">r&#39;\mbox{Dictionary Instantiation: }C =&#39;</span><span class="p">,</span> <span class="n">C</span>
<span class="n">lst1</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
<span class="n">D</span> <span class="o">=</span> <span class="n">o3d</span><span class="o">.</span><span class="n">lt</span><span class="p">(</span><span class="n">lst1</span><span class="p">)</span>
<span class="k">print</span> <span class="s">r&#39;\mbox{List} =&#39;</span><span class="p">,</span> <span class="n">latex</span><span class="p">(</span><span class="n">lst1</span><span class="p">)</span>
<span class="k">print</span> <span class="s">r&#39;\mbox{List Instantiation: }D =&#39;</span><span class="p">,</span> <span class="n">D</span>
<span class="n">lst2</span> <span class="o">=</span> <span class="p">[</span><span class="n">ey</span><span class="o">+</span><span class="n">ez</span><span class="p">,</span><span class="n">ex</span><span class="o">+</span><span class="n">ez</span><span class="p">,</span><span class="n">ex</span><span class="o">+</span><span class="n">ey</span><span class="p">]</span>
<span class="n">E</span> <span class="o">=</span> <span class="n">o3d</span><span class="o">.</span><span class="n">lt</span><span class="p">(</span><span class="n">lst2</span><span class="p">)</span>
<span class="k">print</span> <span class="s">r&#39;\mbox{List} =&#39;</span><span class="p">,</span> <span class="n">latex</span><span class="p">(</span><span class="n">lst2</span><span class="p">)</span>
<span class="k">print</span> <span class="s">r&#39;\mbox{List Instantiation: }E =&#39;</span><span class="p">,</span> <span class="n">E</span>
<span class="n">xpdf</span><span class="p">(</span><span class="n">paper</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">12</span><span class="p">),</span><span class="n">crop</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">png</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>with output</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="_images/LtransInst.png"><img alt="_images/LtransInst.png" src="_images/LtransInst.png" style="width: 500px;" /></a>
</div>
<p>The member functions of the <em>Lt</em> class are</p>
<p><em>Lt(A)</em></p>
<blockquote>
<div>Returns the image of the multivector <span class="math">\(A\)</span> under the linear transformation <span class="math">\(L\)</span> where
<span class="math">\(L(A)\)</span> is defined by the
linearity of <span class="math">\(L\)</span>, the vector values <span class="math">\(L\left ( e_{i}\right )\)</span>, and the definition
<span class="math">\(L \left ( e_{i_{1}}\wedge\dots\wedge e_{i_{r}}\right ) = L\left ( e_{i_{1}} \right )
\wedge\dots\wedge L\left ( e_{i_{r}}\right )\)</span>.</div></blockquote>
<p><em>Lt.det()</em></p>
<blockquote>
<div>Returns the determinant (a scalar) of the linear transformation, <span class="math">\(L\)</span>, defined by
<span class="math">\(\det (L)I = L(I)\)</span>.</div></blockquote>
<p><em>Lt.adj()</em></p>
<blockquote>
<div>Returns the adjoint (a linear transformation) of the linear transformation, <span class="math">\(L\)</span>, defined by
<span class="math">\(a\cdot L(b) = b\cdot \bar{L}(a)\)</span> where
<span class="math">\(a\)</span> and <span class="math">\(b\)</span> are any two vectors in the tangent space and <span class="math">\(\bar{L}\)</span> is the adjoint of <span class="math">\(L\)</span>.</div></blockquote>
<p><em>Lt.tr()</em></p>
<blockquote>
<div>Returns the trace (a scalar) of the linear transformation, <span class="math">\(L\)</span>, defined by
<span class="math">\(\f{\operatorname{tr}}{L}=\nabla_{a}\cdot\f{L}{a}\)</span> where <span class="math">\(a\)</span> is a vector in the tangent space.</div></blockquote>
<p><em>Lt.matrix()</em></p>
<blockquote>
<div>Returns the matrix representation (sympy Matrix) of the linear transformation, <span class="math">\(L\)</span>, defined by
<span class="math">\(L\left ( e_{i}\right ) = L_{ij} e_{j}\)</span> where <span class="math">\(L_{ij}\)</span> is the matrix representation.</div></blockquote>
<p>The <em>Ltrans.py</em> demonstrate the use of the various <em>Lt</em> member functions and operators. The operators that can
be used with
linear transformations are <em>+</em>, <em>-</em>, and <em>*</em>. If <span class="math">\(A\)</span> and <span class="math">\(B\)</span> are linear transformations,
<span class="math">\(V\)</span> a multivector,
and <span class="math">\(\alpha\)</span> a
scalar then <span class="math">\((A\pm B)(V) = A(V)\pm B(V)\)</span>, <span class="math">\((AB)(V) = A(B(V))\)</span>, and
<span class="math">\((\alpha A)(V) = \alpha A(V)\)</span>.</p>
<p>The ouput of <em>Ltrans.py</em> is</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="_images/Ltrans.png"><img alt="_images/Ltrans.png" src="_images/Ltrans.png" style="width: 750px;" /></a>
</div>
</div></blockquote>
</div>
<div class="section" id="differential-operators">
<h3>Differential Operators<a class="headerlink" href="#differential-operators" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>For the mathematical treatment of linear mulivector differential operators see section <a class="reference internal" href="#dops"><em>Linear Differential Operators</em></a>.  The is a differential
operator class <em>Dop</em>. However, one never needs to use it directly.  The operators are constructed from linear
combinations of multivector products of the operators <em>Ga.grad</em> and <em>Ga.rgrad</em> as shown in the following code for
both orthogonal rectangular and spherical 3-d coordinate systems.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">sin</span>
<span class="kn">from</span> <span class="nn">printer</span> <span class="kn">import</span> <span class="n">Format</span><span class="p">,</span><span class="n">xpdf</span>
<span class="kn">from</span> <span class="nn">ga</span> <span class="kn">import</span> <span class="n">Ga</span>

<span class="n">Format</span><span class="p">()</span>
<span class="n">coords</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">)</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;x y z&#39;</span><span class="p">,</span><span class="n">real</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="p">(</span><span class="n">o3d</span><span class="p">,</span><span class="n">ex</span><span class="p">,</span><span class="n">ey</span><span class="p">,</span><span class="n">ez</span><span class="p">)</span> <span class="o">=</span> <span class="n">Ga</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="s">&#39;e*x|y|z&#39;</span><span class="p">,</span><span class="n">g</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">)</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">x</span><span class="o">*</span><span class="n">ex</span><span class="o">+</span><span class="n">y</span><span class="o">*</span><span class="n">ey</span><span class="o">+</span><span class="n">z</span><span class="o">*</span><span class="n">ez</span>
<span class="n">I</span> <span class="o">=</span> <span class="n">o3d</span><span class="o">.</span><span class="n">i</span>
<span class="n">v</span> <span class="o">=</span> <span class="n">o3d</span><span class="o">.</span><span class="n">mv</span><span class="p">(</span><span class="s">&#39;v&#39;</span><span class="p">,</span><span class="s">&#39;vector&#39;</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">o3d</span><span class="o">.</span><span class="n">mv</span><span class="p">(</span><span class="s">&#39;f&#39;</span><span class="p">,</span><span class="s">&#39;scalar&#39;</span><span class="p">,</span><span class="n">f</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">o3d</span><span class="o">.</span><span class="n">mv</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">,</span><span class="s">&#39;vector&#39;</span><span class="p">,</span><span class="n">f</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">dd</span> <span class="o">=</span> <span class="n">v</span><span class="o">|</span><span class="n">o3d</span><span class="o">.</span><span class="n">grad</span>
<span class="n">lap</span> <span class="o">=</span> <span class="n">o3d</span><span class="o">.</span><span class="n">grad</span><span class="o">*</span><span class="n">o3d</span><span class="o">.</span><span class="n">grad</span>
<span class="k">print</span> <span class="s">r&#39;\bm{X} =&#39;</span><span class="p">,</span><span class="n">X</span>
<span class="k">print</span> <span class="s">r&#39;\bm{v} =&#39;</span><span class="p">,</span><span class="n">v</span>
<span class="k">print</span> <span class="s">r&#39;\bm{A} =&#39;</span><span class="p">,</span> <span class="n">A</span>
<span class="k">print</span> <span class="s">r&#39;%\bm{v}\cdot\nabla =&#39;</span><span class="p">,</span> <span class="n">dd</span>
<span class="k">print</span> <span class="s">r&#39;%\nabla^{2} =&#39;</span><span class="p">,</span><span class="n">lap</span>
<span class="k">print</span> <span class="s">r&#39;%\bm{v}\cdot\nabla f =&#39;</span><span class="p">,</span><span class="n">dd</span><span class="o">*</span><span class="n">f</span>
<span class="k">print</span> <span class="s">r&#39;%\nabla^{2} f =&#39;</span><span class="p">,</span><span class="n">lap</span><span class="o">*</span><span class="n">f</span>
<span class="k">print</span> <span class="s">r&#39;%\nabla^{2} \bm{A} =&#39;</span><span class="p">,</span><span class="n">lap</span><span class="o">*</span><span class="n">A</span>
<span class="k">print</span> <span class="s">r&#39;%\bar{\nabla}\cdot v =&#39;</span><span class="p">,</span> <span class="n">o3d</span><span class="o">.</span><span class="n">rgrad</span><span class="o">|</span><span class="n">v</span>
<span class="n">Xgrad</span> <span class="o">=</span> <span class="n">X</span><span class="o">|</span><span class="n">o3d</span><span class="o">.</span><span class="n">grad</span>
<span class="n">rgradX</span> <span class="o">=</span> <span class="n">o3d</span><span class="o">.</span><span class="n">rgrad</span><span class="o">|</span><span class="n">X</span>
<span class="k">print</span> <span class="s">r&#39;%\bm{X}\cdot \nabla =&#39;</span><span class="p">,</span> <span class="n">Xgrad</span>
<span class="k">print</span> <span class="s">r&#39;%\bar{\nabla}\cdot \bm{X} =&#39;</span><span class="p">,</span> <span class="n">rgradX</span>
<span class="n">com</span> <span class="o">=</span> <span class="n">Xgrad</span> <span class="o">-</span> <span class="n">rgradX</span>
<span class="k">print</span> <span class="s">r&#39;%\bm{X}\cdot \nabla - \bar{\nabla}\cdot \bm{X} =&#39;</span><span class="p">,</span> <span class="n">com</span>
<span class="n">sph_coords</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">th</span><span class="p">,</span><span class="n">phi</span><span class="p">)</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;r theta phi&#39;</span><span class="p">,</span><span class="n">real</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="p">(</span><span class="n">sp3d</span><span class="p">,</span><span class="n">er</span><span class="p">,</span><span class="n">eth</span><span class="p">,</span><span class="n">ephi</span><span class="p">)</span> <span class="o">=</span> <span class="n">Ga</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="s">&#39;e&#39;</span><span class="p">,</span><span class="n">g</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">r</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="n">r</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">th</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">],</span><span class="n">coords</span><span class="o">=</span><span class="n">sph_coords</span><span class="p">,</span><span class="n">norm</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">sp3d</span><span class="o">.</span><span class="n">mv</span><span class="p">(</span><span class="s">&#39;f&#39;</span><span class="p">,</span><span class="s">&#39;scalar&#39;</span><span class="p">,</span><span class="n">f</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">lap</span> <span class="o">=</span> <span class="n">sp3d</span><span class="o">.</span><span class="n">grad</span><span class="o">*</span><span class="n">sp3d</span><span class="o">.</span><span class="n">grad</span>
<span class="k">print</span> <span class="s">r&#39;%\nabla^{2} = \nabla\cdot\nabla =&#39;</span><span class="p">,</span> <span class="n">lap</span>
<span class="k">print</span> <span class="s">r&#39;%\lp\nabla^{2}\rp f =&#39;</span><span class="p">,</span> <span class="n">lap</span><span class="o">*</span><span class="n">f</span>
<span class="k">print</span> <span class="s">r&#39;%\nabla\cdot\lp\nabla f\rp =&#39;</span><span class="p">,</span><span class="n">sp3d</span><span class="o">.</span><span class="n">grad</span><span class="o">|</span><span class="p">(</span><span class="n">sp3d</span><span class="o">.</span><span class="n">grad</span><span class="o">*</span><span class="n">f</span><span class="p">)</span>
<span class="n">xpdf</span><span class="p">(</span><span class="n">paper</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">),</span><span class="n">crop</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">png</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>The output of this code is.</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="_images/dop.png"><img alt="_images/dop.png" src="_images/dop.png" style="width: 600px;" /></a>
</div>
</div></blockquote>
</div>
<div class="section" id="instantiating-a-multi-linear-functions-tensors">
<h3>Instantiating a Multi-linear Functions (Tensors)<a class="headerlink" href="#instantiating-a-multi-linear-functions-tensors" title="Permalink to this headline">¶</a></h3>
<p>The mathematical background for multi-linear functions is in section <a class="reference internal" href="#mltrans"><em>Multi-Linear Transformations (Tensors)</em></a>.  To instantiate a multi-linear function use</p>
<p><em>Mlt(self, f, Ga, nargs=None, fct=False)</em> where the arguments are</p>
<blockquote>
<div><a class="reference internal image-reference" href="_images/tensor_inst.png"><img alt="_images/tensor_inst.png" class="align-center" src="_images/tensor_inst.png" style="width: 600px;" /></a>
</div></blockquote>
<p>Examples of different types of instantiation are</p>
<blockquote>
<div><div class="highlight-python"><div class="highlight"><pre><span class="c">#TensorDef.py</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span><span class="p">,</span><span class="n">sin</span><span class="p">,</span><span class="n">cos</span>
<span class="kn">from</span> <span class="nn">printer</span> <span class="kn">import</span> <span class="n">Format</span><span class="p">,</span><span class="n">xpdf</span><span class="p">,</span><span class="n">Get_Program</span><span class="p">,</span><span class="n">Print_Function</span>
<span class="kn">from</span> <span class="nn">ga</span> <span class="kn">import</span> <span class="n">Ga</span>
<span class="kn">from</span> <span class="nn">lt</span> <span class="kn">import</span> <span class="n">Mlt</span>

<span class="n">coords</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;t x y z&#39;</span><span class="p">,</span><span class="n">real</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="p">(</span><span class="n">st4d</span><span class="p">,</span><span class="n">g0</span><span class="p">,</span><span class="n">g1</span><span class="p">,</span><span class="n">g2</span><span class="p">,</span><span class="n">g3</span><span class="p">)</span> <span class="o">=</span> <span class="n">Ga</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="s">&#39;gamma*t|x|y|z&#39;</span><span class="p">,</span><span class="n">g</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">)</span>

<span class="n">A</span> <span class="o">=</span> <span class="n">st4d</span><span class="o">.</span><span class="n">mv</span><span class="p">(</span><span class="s">&#39;T&#39;</span><span class="p">,</span><span class="s">&#39;bivector&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">TA</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span><span class="n">a2</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">A</span>
    <span class="k">return</span> <span class="n">A</span> <span class="o">|</span> <span class="p">(</span><span class="n">a1</span> <span class="o">^</span> <span class="n">a2</span><span class="p">)</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">Mlt</span><span class="p">(</span><span class="n">TA</span><span class="p">,</span><span class="n">st4d</span><span class="p">)</span> <span class="c"># Define multi-linear function</span>
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="basic-multilinear-function-class-functions">
<h3>Basic Multilinear Function Class Functions<a class="headerlink" href="#basic-multilinear-function-class-functions" title="Permalink to this headline">¶</a></h3>
<p>If we can instantiate multilinear functions we can use all the multilinear function class functions as described as follows.
See section <a class="reference internal" href="#mltrans"><em>Multi-Linear Transformations (Tensors)</em></a> for the mathematical description of each operation.</p>
<blockquote>
<div><p><em>self(kargs)</em></p>
<blockquote>
<div>Calling function to evaluates multilinear function for T{kargs} list of vector arguments and returns a value.  Note that a
sympy scalar is returned, emph{not} a multilinear function.</div></blockquote>
<p><em>self.contract(slot1,slot2)</em></p>
<blockquote>
<div>Returns contraction of tensor between <em>slot1</em> and <em>slot2</em> where <em>slot1</em> is the index of the first vector argument and
<em>slot2</em> is the index of the second vector argument of the tensor. For example if we have a rank two tensor, <em>T(a1,a2)</em>,
then <em>T.contract(1,2)</em> is the contraction of <em>T</em>.  For this case since there are only two slots there can only be one
contraction.</div></blockquote>
<p><em>self.pdiff(slot)</em></p>
<blockquote>
<div>Returns gradient of tensor, <em>T</em>, with respect to slot vector.  For example if the tensor is <span class="math">\(\f{T}{a_{1},a_{2}}\)</span> then
<em>T.pdiff(2)</em> is <span class="math">\(\nabla_{a_{2}}T\)</span>.  Since <em>T</em> is a scalar function, <em>T.pdiff(2)</em> is a vector function.</div></blockquote>
<p><em>self.cderiv()</em></p>
<blockquote>
<div>Returns covariant derivative of tensor field. If <em>T</em> is a tensor of rank <span class="math">\(k\)</span> then <em>T.cderiv()</em> is a tensor of rank <span class="math">\(k+1\)</span>.
The operation performed is defined in section <a class="reference internal" href="#mltrans"><em>Multi-Linear Transformations (Tensors)</em></a>.</div></blockquote>
</div></blockquote>
</div>
<div class="section" id="standard-printing">
<h3>Standard Printing<a class="headerlink" href="#standard-printing" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>Printing of multivectors is handled by the module <em>printer</em> which contains
a string printer class derived from the sympy string printer class and a latex
printer class derived from the sympy latex printer class.  Additionally, there
is an <em>Eprint</em> class that enhances the console output of sympy to make
the printed output multivectors, functions, and derivatives more readable.
<em>Eprint</em> requires an ansi console such as is supplied in linux/osx or the
program <em>ansicon</em> (github.com/adoxa/ansicon) for windows which replaces <em>cmd.exe</em>.</p>
<p>For a windows user the simplest way to implement ansicon is to use the <em>geany</em>
editor and in the Edit <span class="math">\(\rightarrow\)</span> Preferences <span class="math">\(\rightarrow\)</span> Tools menu replace <em>cmd.exe</em> with
<em>ansicon.exe</em> (be sure to supply the path to <em>ansicon</em>).</p>
<p>If <em>Eprint</em> is called in a program (linux) when multivectors are printed
the basis blades or bases are printed in bold text, functions are printed in red,
and derivative operators in green.</p>
<p>For formatting the multivector output there is the member function</p>
<p><em>Fmt(self,fmt=1,title=None)</em></p>
<blockquote>
<div><em>Fmt</em> is used to control how the multivector is printed with the argument
<em>fmt</em>.  If <em>fmt=1</em> the entire multivector is printed on one line.  If
<em>fmt=2</em> each grade of the multivector is printed on one line.  If <em>fmt=3</em>
each component (base) of the multivector is printed on one line.  If a
<em>title</em> is given then <em>title=multivector</em> is printed.  If the usual print
command is used the entire multivector is printed on one line.</div></blockquote>
</div></blockquote>
</div>
<div class="section" id="latex-printing">
<h3>Latex Printing<a class="headerlink" href="#latex-printing" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>For latex printing one uses one functions from the <em>ga</em> module and one
function from the <em>printer</em> module.  The
functions are</p>
<p><em>Format(Fmode=True,Dmode=True,ipy=False)</em></p>
<blockquote>
<div><p>This function from the <em>ga</em> module turns on latex printing with the
following options</p>
<blockquote>
<div><a class="reference internal image-reference" href="_images/latex_prnt.png"><img alt="_images/latex_prnt.png" class="align-center" src="_images/latex_prnt.png" style="width: 700px;" /></a>
</div></blockquote>
</div></blockquote>
<p><em>xpdf(filename=None,debug=False,paper=(14,11),crop=False)</em></p>
<blockquote>
<div><p>This function from the <em>printer</em> module post-processes the output captured from
print statements, writes the resulting latex strings to the file <em>filename},
processes the file with pdflatex, and displays the resulting pdf file.   All latex files except
the pdf file are deleted. If *debug = True</em> the file <em>filename</em> is printed to
standard output for debugging purposes and <em>filename</em> (the tex file) is saved.  If <em>filename</em> is not entered the default
filename is the root name of the python program being executed with <em>.tex</em> appended.
The <em>paper</em> option defines the size of the paper sheet for latex. The format for the <em>paper</em> is</p>
<blockquote>
<div><a class="reference internal image-reference" href="_images/latex_paper.png"><img alt="_images/latex_paper.png" class="align-center" src="_images/latex_paper.png" style="width: 600px;" /></a>
</div></blockquote>
<p>The default of <em>paper=(14,11)</em> was chosen so that long multivector expressions would not be truncated on the display.</p>
<p>If the <em>crop</em> input is <em>True</em> the linux <em>pdfcrop</em> program is used to crop the pdf output (if output is one page).  This only works
for linux installations (where <em>pdfcrop</em> is installed).</p>
<p>The <em>xpdf</em> function requires that latex and a pdf viewer be installed on
the computer.</p>
<p><em>xpdf</em> is not required when printing latex in IPython notebook.</p>
</div></blockquote>
<p>As an example of using the latex printing options when the following code is
executed</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">printer</span> <span class="kn">import</span> <span class="n">Format</span><span class="p">,</span> <span class="n">xpdf</span>
<span class="kn">from</span> <span class="nn">ga</span> <span class="kn">import</span> <span class="n">Ga</span>
<span class="n">Format</span><span class="p">()</span>
<span class="n">g3d</span> <span class="o">=</span> <span class="n">Ga</span><span class="p">(</span><span class="s">&#39;e*x|y|z&#39;</span><span class="p">)</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">g3d</span><span class="o">.</span><span class="n">mv</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">,</span><span class="s">&#39;mv&#39;</span><span class="p">)</span>
<span class="k">print</span> <span class="s">r&#39;\bm{A} =&#39;</span><span class="p">,</span><span class="n">A</span>
<span class="n">A</span><span class="o">.</span><span class="n">Fmt</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="s">r&#39;\bm{A}&#39;</span><span class="p">)</span>
<span class="n">A</span><span class="o">.</span><span class="n">Fmt</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="s">r&#39;\bm{A}&#39;</span><span class="p">)</span>
<span class="n">xpdf</span><span class="p">(</span><span class="n">crop</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">png</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>The following is displayed</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="_images/print_example1.png"><img alt="_images/print_example1.png" src="_images/print_example1.png" style="width: 700px;" /></a>
</div>
<p>For the cases of derivatives the code is</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">printer</span> <span class="kn">import</span> <span class="n">Format</span><span class="p">,</span> <span class="n">xpdf</span>
<span class="kn">from</span> <span class="nn">ga</span> <span class="kn">import</span> <span class="n">Ga</span>
<span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span>

<span class="n">Format</span><span class="p">()</span>
<span class="n">X</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">)</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;x y z&#39;</span><span class="p">)</span>
<span class="n">o3d</span> <span class="o">=</span> <span class="n">Ga</span><span class="p">(</span><span class="s">&#39;e_x e_y e_z&#39;</span><span class="p">,</span><span class="n">g</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="n">coords</span><span class="o">=</span><span class="n">X</span><span class="p">)</span>

<span class="n">f</span> <span class="o">=</span> <span class="n">o3d</span><span class="o">.</span><span class="n">mv</span><span class="p">(</span><span class="s">&#39;f&#39;</span><span class="p">,</span><span class="s">&#39;scalar&#39;</span><span class="p">,</span><span class="n">f</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">o3d</span><span class="o">.</span><span class="n">mv</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">,</span><span class="s">&#39;vector&#39;</span><span class="p">,</span><span class="n">f</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">o3d</span><span class="o">.</span><span class="n">mv</span><span class="p">(</span><span class="s">&#39;B&#39;</span><span class="p">,</span><span class="s">&#39;bivector&#39;</span><span class="p">,</span><span class="n">f</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="k">print</span> <span class="s">r&#39;\bm{A} =&#39;</span><span class="p">,</span><span class="n">A</span>
<span class="k">print</span> <span class="s">r&#39;\bm{B} =&#39;</span><span class="p">,</span><span class="n">B</span>

<span class="k">print</span> <span class="s">&#39;grad*f =&#39;</span><span class="p">,</span><span class="n">o3d</span><span class="o">.</span><span class="n">grad</span><span class="o">*</span><span class="n">f</span>
<span class="k">print</span> <span class="s">r&#39;grad|\bm{A} =&#39;</span><span class="p">,</span><span class="n">o3d</span><span class="o">.</span><span class="n">grad</span><span class="o">|</span><span class="n">A</span>
<span class="p">(</span><span class="n">o3d</span><span class="o">.</span><span class="n">grad</span><span class="o">*</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">Fmt</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="s">r&#39;grad*\bm{A}&#39;</span><span class="p">)</span>

<span class="k">print</span> <span class="s">r&#39;-I*(grad^\bm{A}) =&#39;</span><span class="p">,</span><span class="o">-</span><span class="n">o3d</span><span class="o">.</span><span class="n">mv_I</span><span class="o">*</span><span class="p">(</span><span class="n">o3d</span><span class="o">.</span><span class="n">grad</span><span class="o">^</span><span class="n">A</span><span class="p">)</span>
<span class="p">(</span><span class="n">o3d</span><span class="o">.</span><span class="n">grad</span><span class="o">*</span><span class="n">B</span><span class="p">)</span><span class="o">.</span><span class="n">Fmt</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="s">r&#39;grad*\bm{B}&#39;</span><span class="p">)</span>
<span class="k">print</span> <span class="s">r&#39;grad^\bm{B} =&#39;</span><span class="p">,</span><span class="n">o3d</span><span class="o">.</span><span class="n">grad</span><span class="o">^</span><span class="n">B</span>
<span class="k">print</span> <span class="s">r&#39;grad|\bm{B} =&#39;</span><span class="p">,</span><span class="n">o3d</span><span class="o">.</span><span class="n">grad</span><span class="o">|</span><span class="n">B</span>

<span class="n">xpdf</span><span class="p">(</span><span class="n">crop</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">png</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>and the latex displayed output is (<span class="math">\(f\)</span> is a scalar function)</p>
<div class="figure align-center">
<a class="reference internal image-reference" href="_images/print_example2.png"><img alt="_images/print_example2.png" src="_images/print_example2.png" style="width: 700px;" /></a>
</div>
<p>This example also demonstrates several other features of the latex printer.  In the
case that strings are input into the latex printer such as <em>grad*\bm{A}</em>,
<em>grad^\bm{A}</em>, or <em>grad*\bm{A}&#8217;!.  The text symbols *grad</em>, <em>^</em>, <em>|</em>, and
<em>*</em> are mapped by the <em>xpdf()</em> post-processor as follows if the string contains
an <em>=</em>.</p>
<a class="reference internal image-reference" href="_images/latex_replc.png"><img alt="_images/latex_replc.png" class="align-center" src="_images/latex_replc.png" style="width: 375px;" /></a>
<p>If the first character in the string to be printed is a <em>%</em> none of the above substitutions
are made before the latex processor is applied.  In general for the latex
printer strings are assumed to be in a math environment (equation or
align) unless the first character in the string is a <em>#</em>. <a class="footnote-reference" href="#f3" id="id11">[4]</a></p>
<blockquote>
<div>Except where noted the conventions for latex printing follow those of the
latex printing module of sympy. This includes translating sympy variables
with Greek name (such as <em>alpha</em>) to the equivalent Greek symbol
(math:<cite>alpha</cite>) for the purpose of latex printing.  Also a single
underscore in the variable name (such as <em>X_j</em>) indicates a subscript
(<span class="math">\(X_{j}\)</span>), and a double underscore (such as <em>X__k</em>) a
superscript (<span class="math">\(X^{k}\)</span>).  The only other change with regard to the
sympy latex printer is that matrices are printed full size (equation
displaystyle).</div></blockquote>
</div></blockquote>
<p>For formatting the tensor (<em>Mlt</em>) output there is the member function</p>
<p><em>Fmt(self,cnt=1,title=None)</em></p>
<blockquote>
<div><em>Fmt</em> is used to control how the tensor is printed with the argument
<em>cnt</em>.  If <em>cnt=1</em> the each tensor component is printed on one line.  If
<em>fmt=n</em> <span class="math">\(n\)</span> tensor components are printed on one line.  If a
<em>title</em> is given then <em>title=tensor</em> is printed.  If the usual print
command is used one tensor component is printed on one line. If <em>cnt</em> is
greater or equal to the number of tensor components then the entire tensor
is printer on one line.</div></blockquote>
</div>
</div>
<div class="section" id="examples">
<h2>Examples<a class="headerlink" href="#examples" title="Permalink to this headline">¶</a></h2>
<div class="section" id="algebra">
<h3>Algebra<a class="headerlink" href="#algebra" title="Permalink to this headline">¶</a></h3>
<div class="section" id="bac-cab-formulas">
<h4>BAC-CAB Formulas<a class="headerlink" href="#bac-cab-formulas" title="Permalink to this headline">¶</a></h4>
<p>This example demonstrates the most general metric tensor</p>
<div class="math">
\[\begin{equation}
g_{ij} = \left [ \begin{array}{cccc} \left ( a\cdot a\right )  & \left ( a\cdot b\right )  & \left ( a\cdot c\right )  & \left ( a\cdot d\right )  \\
\left ( a\cdot b\right )  & \left ( b\cdot b\right )  & \left ( b\cdot c\right )  & \left ( b\cdot d\right )  \\
\left ( a\cdot c\right )  & \left ( b\cdot c\right )  & \left ( c\cdot c\right )  & \left ( c\cdot d\right )  \\
\left ( a\cdot d\right )  & \left ( b\cdot d\right )  & \left ( c\cdot d\right )  & \left ( d\cdot d\right )
\end{array}\right ]
\end{equation}\]</div><p>and how the <em>galgebra</em> module can be used to verify and expand geometric algebra identities consisting of relations between
the abstract vectors <span class="math">\(a\)</span>, <span class="math">\(b\)</span>, <span class="math">\(c\)</span>, and <span class="math">\(d\)</span>.</p>
<blockquote>
<div><div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">printer</span> <span class="kn">import</span> <span class="n">Format</span><span class="p">,</span> <span class="n">xpdf</span>
<span class="kn">from</span> <span class="nn">ga</span> <span class="kn">import</span> <span class="n">Ga</span>
<span class="kn">from</span> <span class="nn">mv</span> <span class="kn">import</span> <span class="n">Com</span>
<span class="n">Format</span><span class="p">()</span>

<span class="p">(</span><span class="n">g4d</span><span class="p">,</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p">)</span> <span class="o">=</span> <span class="n">Ga</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="s">&#39;a b c d&#39;</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&#39;</span><span class="se">\\</span><span class="s">bm{a|(b*c)} =&#39;</span><span class="p">,</span><span class="n">a</span><span class="o">|</span><span class="p">(</span><span class="n">b</span><span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&#39;</span><span class="se">\\</span><span class="s">bm{a|(b^c)} =&#39;</span><span class="p">,</span><span class="n">a</span><span class="o">|</span><span class="p">(</span><span class="n">b</span><span class="o">^</span><span class="n">c</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&#39;</span><span class="se">\\</span><span class="s">bm{a|(b^c^d)} =&#39;</span><span class="p">,</span><span class="n">a</span><span class="o">|</span><span class="p">(</span><span class="n">b</span><span class="o">^</span><span class="n">c</span><span class="o">^</span><span class="n">d</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&#39;</span><span class="se">\\</span><span class="s">bm{a|(b^c)+c|(a^b)+b|(c^a)} =&#39;</span><span class="p">,(</span><span class="n">a</span><span class="o">|</span><span class="p">(</span><span class="n">b</span><span class="o">^</span><span class="n">c</span><span class="p">))</span><span class="o">+</span><span class="p">(</span><span class="n">c</span><span class="o">|</span><span class="p">(</span><span class="n">a</span><span class="o">^</span><span class="n">b</span><span class="p">))</span><span class="o">+</span><span class="p">(</span><span class="n">b</span><span class="o">|</span><span class="p">(</span><span class="n">c</span><span class="o">^</span><span class="n">a</span><span class="p">))</span>
<span class="k">print</span> <span class="s">&#39;</span><span class="se">\\</span><span class="s">bm{a*(b^c)-b*(a^c)+c*(a^b)} =&#39;</span><span class="p">,</span><span class="n">a</span><span class="o">*</span><span class="p">(</span><span class="n">b</span><span class="o">^</span><span class="n">c</span><span class="p">)</span><span class="o">-</span><span class="n">b</span><span class="o">*</span><span class="p">(</span><span class="n">a</span><span class="o">^</span><span class="n">c</span><span class="p">)</span><span class="o">+</span><span class="n">c</span><span class="o">*</span><span class="p">(</span><span class="n">a</span><span class="o">^</span><span class="n">b</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&#39;</span><span class="se">\\</span><span class="s">bm{a*(b^c^d)-b*(a^c^d)+c*(a^b^d)-d*(a^b^c)} =&#39;</span><span class="p">,</span><span class="n">a</span><span class="o">*</span><span class="p">(</span><span class="n">b</span><span class="o">^</span><span class="n">c</span><span class="o">^</span><span class="n">d</span><span class="p">)</span><span class="o">-</span><span class="n">b</span><span class="o">*</span><span class="p">(</span><span class="n">a</span><span class="o">^</span><span class="n">c</span><span class="o">^</span><span class="n">d</span><span class="p">)</span><span class="o">+</span><span class="n">c</span><span class="o">*</span><span class="p">(</span><span class="n">a</span><span class="o">^</span><span class="n">b</span><span class="o">^</span><span class="n">d</span><span class="p">)</span><span class="o">-</span><span class="n">d</span><span class="o">*</span><span class="p">(</span><span class="n">a</span><span class="o">^</span><span class="n">b</span><span class="o">^</span><span class="n">c</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&#39;</span><span class="se">\\</span><span class="s">bm{(a^b)|(c^d)} =&#39;</span><span class="p">,(</span><span class="n">a</span><span class="o">^</span><span class="n">b</span><span class="p">)</span><span class="o">|</span><span class="p">(</span><span class="n">c</span><span class="o">^</span><span class="n">d</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&#39;</span><span class="se">\\</span><span class="s">bm{((a^b)|c)|d} =&#39;</span><span class="p">,((</span><span class="n">a</span><span class="o">^</span><span class="n">b</span><span class="p">)</span><span class="o">|</span><span class="n">c</span><span class="p">)</span><span class="o">|</span><span class="n">d</span>
<span class="k">print</span> <span class="s">&#39;</span><span class="se">\\</span><span class="s">bm{(a^b)</span><span class="se">\\</span><span class="s">times (c^d)} =&#39;</span><span class="p">,</span><span class="n">Com</span><span class="p">(</span><span class="n">a</span><span class="o">^</span><span class="n">b</span><span class="p">,</span><span class="n">c</span><span class="o">^</span><span class="n">d</span><span class="p">)</span>

<span class="n">xpdf</span><span class="p">(</span><span class="n">crop</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">png</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>The preceeding code block also demonstrates the mapping of <em>*</em>, <em>^</em>, and <em>|</em> to appropriate latex
symbols.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The <span class="math">\(\times\)</span> symbol is the commutator product of two multivectors, <span class="math">\(A\times B = (AB-BA)/2\)</span>.</p>
</div>
<p>The output of the code is</p>
<a class="reference internal image-reference" href="_images/baccab.png"><img alt="_images/baccab.png" class="align-center" src="_images/baccab.png" style="width: 500px;" /></a>
</div>
<div class="section" id="reciprocal-frame">
<h4>Reciprocal Frame<a class="headerlink" href="#reciprocal-frame" title="Permalink to this headline">¶</a></h4>
<p>The reciprocal frame of vectors with respect to the basis vectors is required
for the evaluation of the geometric dervative.  The following example demonstrates
that for the case of an arbitrary 3-dimensional Euclidian basis the reciprocal
basis vectors are correctly calculated.</p>
<blockquote>
<div><div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">expand</span><span class="p">,</span> <span class="n">simplify</span>
<span class="kn">from</span> <span class="nn">ga</span> <span class="kn">import</span> <span class="n">Ga</span>
<span class="kn">from</span> <span class="nn">printer</span> <span class="kn">import</span> <span class="n">Format</span><span class="p">,</span> <span class="n">xpdf</span>

<span class="n">Format</span><span class="p">()</span>

<span class="n">g</span> <span class="o">=</span> <span class="s">&#39;1 # #,&#39;</span><span class="o">+</span> \
    <span class="s">&#39;# 1 #,&#39;</span><span class="o">+</span> \
    <span class="s">&#39;# # 1&#39;</span>

<span class="n">ng3d</span> <span class="o">=</span> <span class="n">Ga</span><span class="p">(</span><span class="s">&#39;e1 e2 e3&#39;</span><span class="p">,</span><span class="n">g</span><span class="o">=</span><span class="n">g</span><span class="p">)</span>
<span class="p">(</span><span class="n">e1</span><span class="p">,</span><span class="n">e2</span><span class="p">,</span><span class="n">e3</span><span class="p">)</span> <span class="o">=</span> <span class="n">ng3d</span><span class="o">.</span><span class="n">mv</span><span class="p">()</span>

<span class="k">print</span> <span class="s">&#39;g_{ij} =&#39;</span><span class="p">,</span><span class="n">ng3d</span><span class="o">.</span><span class="n">g</span>

<span class="n">E</span> <span class="o">=</span> <span class="n">e1</span><span class="o">^</span><span class="n">e2</span><span class="o">^</span><span class="n">e3</span>
<span class="n">Esq</span> <span class="o">=</span> <span class="p">(</span><span class="n">E</span><span class="o">*</span><span class="n">E</span><span class="p">)</span><span class="o">.</span><span class="n">scalar</span><span class="p">()</span>
<span class="k">print</span> <span class="s">&#39;E =&#39;</span><span class="p">,</span><span class="n">E</span>
<span class="k">print</span> <span class="s">&#39;</span><span class="si">%E</span><span class="s">^{2} =&#39;</span><span class="p">,</span><span class="n">Esq</span>
<span class="n">Esq_inv</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">Esq</span>

<span class="n">E1</span> <span class="o">=</span> <span class="p">(</span><span class="n">e2</span><span class="o">^</span><span class="n">e3</span><span class="p">)</span><span class="o">*</span><span class="n">E</span>
<span class="n">E2</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">e1</span><span class="o">^</span><span class="n">e3</span><span class="p">)</span><span class="o">*</span><span class="n">E</span>
<span class="n">E3</span> <span class="o">=</span> <span class="p">(</span><span class="n">e1</span><span class="o">^</span><span class="n">e2</span><span class="p">)</span><span class="o">*</span><span class="n">E</span>

<span class="k">print</span> <span class="s">&#39;E1 = (e2^e3)*E =&#39;</span><span class="p">,</span><span class="n">E1</span>
<span class="k">print</span> <span class="s">&#39;E2 =-(e1^e3)*E =&#39;</span><span class="p">,</span><span class="n">E2</span>
<span class="k">print</span> <span class="s">&#39;E3 = (e1^e2)*E =&#39;</span><span class="p">,</span><span class="n">E3</span>

<span class="n">w</span> <span class="o">=</span> <span class="p">(</span><span class="n">E1</span><span class="o">|</span><span class="n">e2</span><span class="p">)</span>
<span class="n">w</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
<span class="k">print</span> <span class="s">&#39;E1|e2 =&#39;</span><span class="p">,</span><span class="n">w</span>

<span class="n">w</span> <span class="o">=</span> <span class="p">(</span><span class="n">E1</span><span class="o">|</span><span class="n">e3</span><span class="p">)</span>
<span class="n">w</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
<span class="k">print</span> <span class="s">&#39;E1|e3 =&#39;</span><span class="p">,</span><span class="n">w</span>

<span class="n">w</span> <span class="o">=</span> <span class="p">(</span><span class="n">E2</span><span class="o">|</span><span class="n">e1</span><span class="p">)</span>
<span class="n">w</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
<span class="k">print</span> <span class="s">&#39;E2|e1 =&#39;</span><span class="p">,</span><span class="n">w</span>

<span class="n">w</span> <span class="o">=</span> <span class="p">(</span><span class="n">E2</span><span class="o">|</span><span class="n">e3</span><span class="p">)</span>
<span class="n">w</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
<span class="k">print</span> <span class="s">&#39;E2|e3 =&#39;</span><span class="p">,</span><span class="n">w</span>

<span class="n">w</span> <span class="o">=</span> <span class="p">(</span><span class="n">E3</span><span class="o">|</span><span class="n">e1</span><span class="p">)</span>
<span class="n">w</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
<span class="k">print</span> <span class="s">&#39;E3|e1 =&#39;</span><span class="p">,</span><span class="n">w</span>

<span class="n">w</span> <span class="o">=</span> <span class="p">(</span><span class="n">E3</span><span class="o">|</span><span class="n">e2</span><span class="p">)</span>
<span class="n">w</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">expand</span><span class="p">()</span>
<span class="k">print</span> <span class="s">&#39;E3|e2 =&#39;</span><span class="p">,</span><span class="n">w</span>

<span class="n">w</span> <span class="o">=</span> <span class="p">(</span><span class="n">E1</span><span class="o">|</span><span class="n">e1</span><span class="p">)</span>
<span class="n">w</span> <span class="o">=</span> <span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">expand</span><span class="p">())</span><span class="o">.</span><span class="n">scalar</span><span class="p">()</span>
<span class="n">Esq</span> <span class="o">=</span> <span class="n">expand</span><span class="p">(</span><span class="n">Esq</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&#39;%(E1</span><span class="se">\\</span><span class="s">cdot e1)/E^{2} =&#39;</span><span class="p">,</span><span class="n">simplify</span><span class="p">(</span><span class="n">w</span><span class="o">/</span><span class="n">Esq</span><span class="p">)</span>

<span class="n">w</span> <span class="o">=</span> <span class="p">(</span><span class="n">E2</span><span class="o">|</span><span class="n">e2</span><span class="p">)</span>
<span class="n">w</span> <span class="o">=</span> <span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">expand</span><span class="p">())</span><span class="o">.</span><span class="n">scalar</span><span class="p">()</span>
<span class="k">print</span> <span class="s">&#39;%(E2</span><span class="se">\\</span><span class="s">cdot e2)/E^{2} =&#39;</span><span class="p">,</span><span class="n">simplify</span><span class="p">(</span><span class="n">w</span><span class="o">/</span><span class="n">Esq</span><span class="p">)</span>

<span class="n">w</span> <span class="o">=</span> <span class="p">(</span><span class="n">E3</span><span class="o">|</span><span class="n">e3</span><span class="p">)</span>
<span class="n">w</span> <span class="o">=</span> <span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">expand</span><span class="p">())</span><span class="o">.</span><span class="n">scalar</span><span class="p">()</span>
<span class="k">print</span> <span class="s">&#39;%(E3</span><span class="se">\\</span><span class="s">cdot e3)/E^{2} =&#39;</span><span class="p">,</span><span class="n">simplify</span><span class="p">(</span><span class="n">w</span><span class="o">/</span><span class="n">Esq</span><span class="p">)</span>

<span class="n">xpdf</span><span class="p">(</span><span class="n">crop</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">png</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>The preceeding code also demonstrated the use of the <em>%</em> directive in
printing a string so that <em>^</em> is treated literally and not translated
to <em>\wedge</em>. Note that &#8220;%E^{2} =&#8221; is printed as &#8220;<span class="math">\(E^{2} =\)</span>&#8221;
and not as &#8220;<span class="math">\(E\wedge {2} =\)</span>&#8221;.</p>
<a class="reference internal image-reference" href="_images/recp_frame.png"><img alt="_images/recp_frame.png" class="align-center" src="_images/recp_frame.png" style="width: 800px;" /></a>
<p>The formulas derived for <span class="math">\(E1\)</span>, <span class="math">\(E2\)</span>, <span class="math">\(E3\)</span>, and <span class="math">\(E^{2}\)</span> could
also be applied to the numerical calculations of crystal properties.</p>
</div>
<div class="section" id="lorentz-transformation">
<h4>Lorentz-Transformation<a class="headerlink" href="#lorentz-transformation" title="Permalink to this headline">¶</a></h4>
<p>A simple physics demonstation of geometric algebra is the derivation of
the Lorentz-Transformation.  In this demonstration a 2-dimensional
Minkowski space is defined and the Lorentz-Transformation is generated
from a rotation of a vector in the Minkowski space using the rotor
<span class="math">\(R\)</span>.</p>
<blockquote>
<div><div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span>
<span class="kn">from</span> <span class="nn">ga</span> <span class="kn">import</span> <span class="n">Ga</span>
<span class="kn">from</span> <span class="nn">printer</span> <span class="kn">import</span> <span class="n">Format</span><span class="p">,</span> <span class="n">xpdf</span>

<span class="n">Format</span><span class="p">()</span>

<span class="p">(</span><span class="n">alpha</span><span class="p">,</span><span class="n">beta</span><span class="p">,</span><span class="n">gamma</span><span class="p">)</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;alpha beta gamma&#39;</span><span class="p">)</span>
<span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">t</span><span class="p">,</span><span class="n">xp</span><span class="p">,</span><span class="n">tp</span><span class="p">)</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&quot;x t x&#39; t&#39;&quot;</span><span class="p">,</span><span class="n">real</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="p">(</span><span class="n">st2d</span><span class="p">,</span><span class="n">g0</span><span class="p">,</span><span class="n">g1</span><span class="p">)</span> <span class="o">=</span> <span class="n">Ga</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="s">&#39;gamma*t|x&#39;</span><span class="p">,</span><span class="n">g</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

<span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">sinh</span><span class="p">,</span><span class="n">cosh</span>

<span class="n">R</span> <span class="o">=</span> <span class="n">cosh</span><span class="p">(</span><span class="n">alpha</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="n">sinh</span><span class="p">(</span><span class="n">alpha</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">g0</span><span class="o">^</span><span class="n">g1</span><span class="p">)</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">t</span><span class="o">*</span><span class="n">g0</span><span class="o">+</span><span class="n">x</span><span class="o">*</span><span class="n">g1</span>
<span class="n">Xp</span> <span class="o">=</span> <span class="n">tp</span><span class="o">*</span><span class="n">g0</span><span class="o">+</span><span class="n">xp</span><span class="o">*</span><span class="n">g1</span>
<span class="k">print</span> <span class="s">&#39;R =&#39;</span><span class="p">,</span><span class="n">R</span>

<span class="k">print</span> <span class="s">r&quot;#%t\bm{\gamma_{t}}+x\bm{\gamma_{x}} = t&#39;\bm{\gamma&#39;_{t}}+x&#39;\bm{\gamma&#39;_{x}} = R\lp t&#39;\bm{\gamma_{t}}+x&#39;\bm{\gamma_{x}}\rp R^{\dagger}&quot;</span>

<span class="n">Xpp</span> <span class="o">=</span> <span class="n">R</span><span class="o">*</span><span class="n">Xp</span><span class="o">*</span><span class="n">R</span><span class="o">.</span><span class="n">rev</span><span class="p">()</span>
<span class="n">Xpp</span> <span class="o">=</span> <span class="n">Xpp</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
<span class="n">Xpp</span> <span class="o">=</span> <span class="n">Xpp</span><span class="o">.</span><span class="n">trigsimp</span><span class="p">()</span>
<span class="k">print</span> <span class="s">r&quot;%t\bm{\gamma_{t}}+x\bm{\gamma_{x}} =&quot;</span><span class="p">,</span><span class="n">Xpp</span>
<span class="n">Xpp</span> <span class="o">=</span> <span class="n">Xpp</span><span class="o">.</span><span class="n">subs</span><span class="p">({</span><span class="n">sinh</span><span class="p">(</span><span class="n">alpha</span><span class="p">):</span><span class="n">gamma</span><span class="o">*</span><span class="n">beta</span><span class="p">,</span><span class="n">cosh</span><span class="p">(</span><span class="n">alpha</span><span class="p">):</span><span class="n">gamma</span><span class="p">})</span>

<span class="k">print</span> <span class="s">r&#39;%\f{\sinh}{\alpha} = \gamma\beta&#39;</span>
<span class="k">print</span> <span class="s">r&#39;%\f{\cosh}{\alpha} = \gamma&#39;</span>

<span class="k">print</span> <span class="s">r&quot;%t\bm{\gamma_{t}}+x\bm{\gamma_{x}} =&quot;</span><span class="p">,</span><span class="n">Xpp</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>

<span class="n">xpdf</span><span class="p">(</span><span class="n">crop</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">png</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>The preceeding code also demonstrates how to use the sympy <em>subs</em> functions
to perform the hyperbolic half angle transformation.  The code also shows
the use of both the <em>#</em> and <em>%</em> directives in the text string
<tt class="docutils literal"><span class="pre">r&quot;#%t\bm{\gamma_{t}}+x\bm{\gamma_{x}}</span> <span class="pre">=</span> <span class="pre">t'\bm{\gamma'_{t}}+x'\bm{\gamma'_{x}}</span> <span class="pre">=</span> <span class="pre">R\left</span> <span class="pre">(</span> <span class="pre">t'\bm{\gamma_{t}}+x'\bm{\gamma_{x}}\right</span> <span class="pre">)</span> <span class="pre">R^{\dagger}&quot;</span></tt>.
Both the <em>#</em> and <em>%</em> are needed in this text string for two reasons.  First, the text string contains an <em>=</em> sign.  The latex preprocessor
uses this a key to combine the text string with a sympy expression to be printed after the text string.  The <em>#</em> is required to inform
the preprocessor that there is no sympy expression to follow.  Second, the <em>%</em> is requires to inform the preprocessor that the text
string is to be displayed in latex math mode and not in text mode (if <em>#</em> is present the default latex mode is text mode unless
overridden by the <em>%</em> directive).</p>
<a class="reference internal image-reference" href="_images/lorentz_trans.png"><img alt="_images/lorentz_trans.png" class="align-center" src="_images/lorentz_trans.png" style="width: 500px;" /></a>
</div>
<div class="section" id="id12">
<h4>Linear Transformations<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h4>
<p>Examples of linear transformations produced by the following code -</p>
<blockquote>
<div><div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">cos</span>
<span class="kn">from</span> <span class="nn">ga</span> <span class="kn">import</span> <span class="n">Ga</span>
<span class="kn">from</span> <span class="nn">printer</span> <span class="kn">import</span> <span class="n">Format</span><span class="p">,</span> <span class="n">xpdf</span>

<span class="n">Format</span><span class="p">()</span>

<span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">=</span> <span class="n">uv</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;u,v&#39;</span><span class="p">,</span><span class="n">real</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="p">(</span><span class="n">g2d</span><span class="p">,</span> <span class="n">eu</span><span class="p">,</span> <span class="n">ev</span><span class="p">)</span> <span class="o">=</span> <span class="n">Ga</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="s">&#39;e_u e_v&#39;</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="n">uv</span><span class="p">)</span>

<span class="k">print</span> <span class="s">&#39;#$A$ is a general 2D linear transformation&#39;</span>

<span class="n">A2d</span> <span class="o">=</span> <span class="n">g2d</span><span class="o">.</span><span class="n">lt</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">)</span>

<span class="k">print</span> <span class="s">&#39;A =&#39;</span><span class="p">,</span> <span class="n">A2d</span>
<span class="k">print</span> <span class="s">&#39;</span><span class="se">\\</span><span class="s">f{</span><span class="se">\\</span><span class="s">det}{A} =&#39;</span><span class="p">,</span> <span class="n">A2d</span><span class="o">.</span><span class="n">det</span><span class="p">()</span>
<span class="k">print</span> <span class="s">&#39;</span><span class="se">\\</span><span class="s">f{</span><span class="se">\\</span><span class="s">Tr}{A} =&#39;</span><span class="p">,</span> <span class="n">A2d</span><span class="o">.</span><span class="n">tr</span><span class="p">()</span>

<span class="n">B2d</span> <span class="o">=</span> <span class="n">g2d</span><span class="o">.</span><span class="n">lt</span><span class="p">(</span><span class="s">&#39;B&#39;</span><span class="p">)</span>

<span class="k">print</span> <span class="s">&#39;B =&#39;</span><span class="p">,</span> <span class="n">B2d</span>
<span class="k">print</span> <span class="s">&#39;A + B =&#39;</span><span class="p">,</span> <span class="n">A2d</span> <span class="o">+</span> <span class="n">B2d</span>
<span class="k">print</span> <span class="s">&#39;AB =&#39;</span><span class="p">,</span> <span class="n">A2d</span> <span class="o">*</span> <span class="n">B2d</span>
<span class="k">print</span> <span class="s">&#39;A - B =&#39;</span><span class="p">,</span> <span class="n">A2d</span> <span class="o">-</span> <span class="n">B2d</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">g2d</span><span class="o">.</span><span class="n">mv</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">,</span><span class="s">&#39;vector&#39;</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">g2d</span><span class="o">.</span><span class="n">mv</span><span class="p">(</span><span class="s">&#39;b&#39;</span><span class="p">,</span><span class="s">&#39;vector&#39;</span><span class="p">)</span>

<span class="k">print</span> <span class="s">r&#39;a|\f{\overline{A}}{b}-b|\f{\underline{A}}{a} =&#39;</span><span class="p">,((</span><span class="n">a</span><span class="o">|</span><span class="n">A2d</span><span class="o">.</span><span class="n">adj</span><span class="p">()(</span><span class="n">b</span><span class="p">))</span><span class="o">-</span><span class="p">(</span><span class="n">b</span><span class="o">|</span><span class="n">A2d</span><span class="p">(</span><span class="n">a</span><span class="p">)))</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>

<span class="n">m4d</span> <span class="o">=</span> <span class="n">Ga</span><span class="p">(</span><span class="s">&#39;e_t e_x e_y e_z&#39;</span><span class="p">,</span> <span class="n">g</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">coords</span><span class="o">=</span><span class="n">symbols</span><span class="p">(</span><span class="s">&#39;t,x,y,z&#39;</span><span class="p">,</span><span class="n">real</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">m4d</span><span class="o">.</span><span class="n">lt</span><span class="p">(</span><span class="s">&#39;T&#39;</span><span class="p">)</span>

<span class="k">print</span> <span class="s">&#39;#$T$ is a linear transformation in Minkowski space&#39;</span>
<span class="k">print</span> <span class="s">r&#39;\underline{T} =&#39;</span><span class="p">,</span><span class="n">T</span>
<span class="k">print</span> <span class="s">r&#39;\overline{T} =&#39;</span><span class="p">,</span><span class="n">T</span><span class="o">.</span><span class="n">adj</span><span class="p">()</span>
<span class="k">print</span> <span class="s">r&#39;\f{\mbox{tr}}{\underline{T}} =&#39;</span><span class="p">,</span><span class="n">T</span><span class="o">.</span><span class="n">tr</span><span class="p">()</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">m4d</span><span class="o">.</span><span class="n">mv</span><span class="p">(</span><span class="s">&#39;a&#39;</span><span class="p">,</span><span class="s">&#39;vector&#39;</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">m4d</span><span class="o">.</span><span class="n">mv</span><span class="p">(</span><span class="s">&#39;b&#39;</span><span class="p">,</span><span class="s">&#39;vector&#39;</span><span class="p">)</span>

<span class="k">print</span> <span class="s">r&#39;a|\f{\overline{T}}{b}-b|\f{\underline{T}}{a} =&#39;</span><span class="p">,((</span><span class="n">a</span><span class="o">|</span><span class="n">T</span><span class="o">.</span><span class="n">adj</span><span class="p">()(</span><span class="n">b</span><span class="p">))</span><span class="o">-</span><span class="p">(</span><span class="n">b</span><span class="o">|</span><span class="n">T</span><span class="p">(</span><span class="n">a</span><span class="p">)))</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>

<span class="n">xpdf</span><span class="p">(</span><span class="n">crop</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">png</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>Note the trace of the general basis 2-d case and the adjoint for the Minkowski 4-d case.  Also note
the results of the adjoint test for both cases.</p>
<a class="reference internal image-reference" href="_images/Ltrans.png"><img alt="_images/Ltrans.png" class="align-center" src="_images/Ltrans.png" style="width: 800px;" /></a>
</div>
</div>
<div class="section" id="calculus">
<h3>Calculus<a class="headerlink" href="#calculus" title="Permalink to this headline">¶</a></h3>
<div class="section" id="derivatives-in-spherical-coordinates">
<h4>Derivatives in Spherical Coordinates<a class="headerlink" href="#derivatives-in-spherical-coordinates" title="Permalink to this headline">¶</a></h4>
<p>The following code shows how to use <em>galgebra</em> to use spherical coordinates.
The gradient of a scalar function, <span class="math">\(f\)</span>, the divergence and curl
of a vector function, <span class="math">\(A\)</span>, and the exterior derivative (curl) of
a bivector function, <span class="math">\(B\)</span> are calculated.  Note that to get the
standard curl of a 3-dimension function the result is multiplied by
<span class="math">\(-I\)</span> the negative of the pseudoscalar.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>In geometric calculus the operator <span class="math">\(\nabla^{2}\)</span> is well defined
on its own as the geometic derivative of the geometric derivative.
However, if needed we have for the vector function <span class="math">\(A\)</span> the relations
(since <span class="math">\(\nabla\cdot A\)</span> is a scalar it&#8217;s curl is equal to it&#8217;s
geometric derivative and it&#8217;s divergence is zero) -</p>
<div class="math">
\[\begin{align*}
\nabla A =& \nabla\wedge A + \nabla\cdot A \\
\nabla^{2} A =& \nabla\left ( {{\nabla\wedge A}} \right ) + \nabla\left ( {{\nabla\cdot A}} \right ) \\
\nabla^{2} A =& \nabla\wedge\left ( {{\nabla\wedge A}} \right ) + \nabla\cdot\left ( {{\nabla\wedge A}} \right )
+\nabla\wedge\left ( {{\nabla\cdot A}} \right ) + \nabla\cdot\left ( {{\nabla\cdot A}} \right ) \\
\nabla^{2} A =& \nabla\wedge\left ( {{\nabla\wedge A}} \right ) + \left ( {{\nabla\cdot\nabla}} \right ) A
- \nabla\left ( {{\nabla\cdot A}} \right ) + \nabla\left ( {{\nabla\cdot A}} \right ) \\
\nabla^{2} A =& \nabla\wedge\nabla\wedge A + \left ( {{\nabla\cdot\nabla}} \right )A
\end{align*}\]</div><p class="last">In the derivation we have used that <span class="math">\(\nabla\cdot\left ( {{\nabla\wedge A}} \right ) = \left ( {{\nabla\cdot\nabla}} \right )A - \nabla\left ( {{\nabla\cdot A}} \right )\)</span>
which is implicit in the second <em>BAC-CAB</em> formula.
No parenthesis is needed for the geometric curl of the curl (exterior derivative of exterior derivative)
since the <span class="math">\(\wedge\)</span> operation is associative unlike the vector curl operator and <span class="math">\(\nabla\cdot\nabla\)</span> is the usual Laplacian
operator.</p>
</div>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">sin</span>
<span class="kn">from</span> <span class="nn">printer</span> <span class="kn">import</span> <span class="n">Format</span><span class="p">,</span> <span class="n">xpdf</span>
<span class="kn">from</span> <span class="nn">ga</span> <span class="kn">import</span> <span class="n">Ga</span>

<span class="n">Format</span><span class="p">()</span>

<span class="n">X</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">th</span><span class="p">,</span><span class="n">phi</span><span class="p">)</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;r theta phi&#39;</span><span class="p">)</span>
<span class="n">s3d</span> <span class="o">=</span> <span class="n">Ga</span><span class="p">(</span><span class="s">&#39;e_r e_theta e_phi&#39;</span><span class="p">,</span><span class="n">g</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="n">r</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="n">r</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">th</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">],</span><span class="n">coords</span><span class="o">=</span><span class="n">X</span><span class="p">,</span><span class="n">norm</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="p">(</span><span class="n">er</span><span class="p">,</span><span class="n">eth</span><span class="p">,</span><span class="n">ephi</span><span class="p">)</span> <span class="o">=</span> <span class="n">s3d</span><span class="o">.</span><span class="n">mv</span><span class="p">()</span>
<span class="n">grad</span> <span class="o">=</span> <span class="n">s3d</span><span class="o">.</span><span class="n">grad</span>

<span class="n">f</span> <span class="o">=</span> <span class="n">s3d</span><span class="o">.</span><span class="n">mv</span><span class="p">(</span><span class="s">&#39;f&#39;</span><span class="p">,</span><span class="s">&#39;scalar&#39;</span><span class="p">,</span><span class="n">f</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">s3d</span><span class="o">.</span><span class="n">mv</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">,</span><span class="s">&#39;vector&#39;</span><span class="p">,</span><span class="n">f</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">s3d</span><span class="o">.</span><span class="n">mv</span><span class="p">(</span><span class="s">&#39;B&#39;</span><span class="p">,</span><span class="s">&#39;bivector&#39;</span><span class="p">,</span><span class="n">f</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

<span class="k">print</span> <span class="s">&#39;f =&#39;</span><span class="p">,</span><span class="n">f</span>
<span class="k">print</span> <span class="s">&#39;A =&#39;</span><span class="p">,</span><span class="n">A</span>
<span class="k">print</span> <span class="s">&#39;B =&#39;</span><span class="p">,</span><span class="n">B</span>

<span class="k">print</span> <span class="s">&#39;grad*f =&#39;</span><span class="p">,</span><span class="n">grad</span><span class="o">*</span><span class="n">f</span>
<span class="k">print</span> <span class="s">&#39;grad|A =&#39;</span><span class="p">,</span><span class="n">grad</span><span class="o">|</span><span class="n">A</span>
<span class="k">print</span> <span class="s">&#39;-I*(grad^A) =&#39;</span><span class="p">,(</span><span class="o">-</span><span class="n">s3d</span><span class="o">.</span><span class="n">i</span><span class="o">*</span><span class="p">(</span><span class="n">grad</span><span class="o">^</span><span class="n">A</span><span class="p">))</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>
<span class="k">print</span> <span class="s">&#39;grad^B =&#39;</span><span class="p">,</span><span class="n">grad</span><span class="o">^</span><span class="n">B</span>

<span class="n">xpdf</span><span class="p">(</span><span class="n">crop</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">png</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>Results of code</p>
<a class="reference internal image-reference" href="_images/spherical.png"><img alt="_images/spherical.png" class="align-center" src="_images/spherical.png" style="width: 800px;" /></a>
</div>
<div class="section" id="maxwell-s-equations">
<h4>Maxwell&#8217;s Equations<a class="headerlink" href="#maxwell-s-equations" title="Permalink to this headline">¶</a></h4>
<p>The geometric algebra formulation of Maxwell&#8217;s equations is deomonstrated
with the formalism developed in &#8220;Geometric Algebra for Physicists&#8221; <a class="reference internal" href="#doran" id="id13">[Doran]</a>.
In this formalism the signature of the metric is <span class="math">\((1,-1,-1,-1)\)</span> and the
basis vectors are <span class="math">\(\gamma_{t}\)</span>, <span class="math">\(\gamma_{x}\)</span>, <span class="math">\(\gamma_{y}\)</span>,
and <span class="math">\(\gamma_{z}\)</span>.  The if <span class="math">\(\boldsymbol{E}\)</span> and <span class="math">\(\boldsymbol{B}\)</span> are the
normal electric and magnetic field vectors the electric and magnetic
bivectors are given by <span class="math">\(E = \boldsymbol{E}\gamma_{t}\)</span> and <span class="math">\(B = \boldsymbol{B}\gamma_{t}\)</span>.
The electromagnetic bivector is then <span class="math">\(F = E+IB\)</span> where
<span class="math">\(I = \gamma_{t}\gamma_{x}\gamma_{y}\gamma_{z}\)</span> is the pesudo-scalar
for the Minkowski space.  Note that the electromagnetic bivector is isomorphic
to the electromagnetic tensor.  Then if <span class="math">\(J\)</span> is the 4-current all of
Maxwell&#8217;s equations are given by <span class="math">\(\boldsymbol{\nabla}F = J\)</span>.  For more details
see <a class="reference internal" href="#doran" id="id14">[Doran]</a> chapter 7.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span>
<span class="kn">from</span> <span class="nn">printer</span> <span class="kn">import</span> <span class="n">Format</span><span class="p">,</span> <span class="n">xpdf</span>
<span class="kn">from</span> <span class="nn">ga</span> <span class="kn">import</span> <span class="n">Ga</span>

<span class="n">Format</span><span class="p">()</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;t x y z&#39;</span><span class="p">,</span><span class="n">real</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="p">(</span><span class="n">st4d</span><span class="p">,</span><span class="n">g0</span><span class="p">,</span><span class="n">g1</span><span class="p">,</span><span class="n">g2</span><span class="p">,</span><span class="n">g3</span><span class="p">)</span> <span class="o">=</span> <span class="n">Ga</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="s">&#39;gamma*t|x|y|z&#39;</span><span class="p">,</span><span class="n">g</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">coords</span><span class="o">=</span><span class="n">X</span><span class="p">)</span>

<span class="n">I</span> <span class="o">=</span> <span class="n">st4d</span><span class="o">.</span><span class="n">i</span>

<span class="n">B</span> <span class="o">=</span> <span class="n">st4d</span><span class="o">.</span><span class="n">mv</span><span class="p">(</span><span class="s">&#39;B&#39;</span><span class="p">,</span><span class="s">&#39;vector&#39;</span><span class="p">,</span><span class="n">f</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">E</span> <span class="o">=</span> <span class="n">st4d</span><span class="o">.</span><span class="n">mv</span><span class="p">(</span><span class="s">&#39;E&#39;</span><span class="p">,</span><span class="s">&#39;vector&#39;</span><span class="p">,</span><span class="n">f</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">B</span><span class="o">.</span><span class="n">set_coef</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">E</span><span class="o">.</span><span class="n">set_coef</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">B</span> <span class="o">*=</span> <span class="n">g0</span>
<span class="n">E</span> <span class="o">*=</span> <span class="n">g0</span>
<span class="n">J</span> <span class="o">=</span> <span class="n">st4d</span><span class="o">.</span><span class="n">mv</span><span class="p">(</span><span class="s">&#39;J&#39;</span><span class="p">,</span><span class="s">&#39;vector&#39;</span><span class="p">,</span><span class="n">f</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">F</span> <span class="o">=</span> <span class="n">E</span><span class="o">+</span><span class="n">I</span><span class="o">*</span><span class="n">B</span>

<span class="k">print</span> <span class="s">r&#39;\text{Pseudo Scalar\;\;}I =&#39;</span><span class="p">,</span><span class="n">I</span>
<span class="k">print</span> <span class="s">&#39;</span><span class="se">\\</span><span class="s">text{Magnetic Field Bi-Vector</span><span class="se">\\</span><span class="s">;</span><span class="se">\\</span><span class="s">;} B = </span><span class="se">\\</span><span class="s">bm{B</span><span class="se">\\</span><span class="s">gamma_{t}} =&#39;</span><span class="p">,</span><span class="n">B</span>
<span class="k">print</span> <span class="s">&#39;</span><span class="se">\\</span><span class="s">text{Electric Field Bi-Vector</span><span class="se">\\</span><span class="s">;</span><span class="se">\\</span><span class="s">;} E = </span><span class="se">\\</span><span class="s">bm{E</span><span class="se">\\</span><span class="s">gamma_{t}} =&#39;</span><span class="p">,</span><span class="n">E</span>
<span class="k">print</span> <span class="s">&#39;</span><span class="se">\\</span><span class="s">text{Electromagnetic Field Bi-Vector</span><span class="se">\\</span><span class="s">;</span><span class="se">\\</span><span class="s">;} F = E+IB =&#39;</span><span class="p">,</span><span class="n">F</span>
<span class="k">print</span> <span class="s">&#39;%</span><span class="se">\\</span><span class="s">text{Four Current Density</span><span class="se">\\</span><span class="s">;</span><span class="se">\\</span><span class="s">;} J =&#39;</span><span class="p">,</span><span class="n">J</span>
<span class="n">gradF</span> <span class="o">=</span> <span class="n">st4d</span><span class="o">.</span><span class="n">grad</span><span class="o">*</span><span class="n">F</span>
<span class="k">print</span> <span class="s">&#39;#Geom Derivative of Electomagnetic Field Bi-Vector&#39;</span>
<span class="n">gradF</span><span class="o">.</span><span class="n">Fmt</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="s">&#39;grad*F&#39;</span><span class="p">)</span>

<span class="k">print</span> <span class="s">&#39;#Maxwell Equations&#39;</span>
<span class="k">print</span> <span class="s">&#39;grad*F = J&#39;</span>
<span class="k">print</span> <span class="s">&#39;#Div $E$ and Curl $H$ Equations&#39;</span>
<span class="p">(</span><span class="n">gradF</span><span class="o">.</span><span class="n">get_grade</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="n">J</span><span class="p">)</span><span class="o">.</span><span class="n">Fmt</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="s">&#39;%</span><span class="se">\\</span><span class="s">grade{</span><span class="se">\\</span><span class="s">nabla F}_{1} -J = 0&#39;</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&#39;#Curl $E$ and Div $B$ equations&#39;</span>
<span class="p">(</span><span class="n">gradF</span><span class="o">.</span><span class="n">get_grade</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">Fmt</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="s">&#39;%</span><span class="se">\\</span><span class="s">grade{</span><span class="se">\\</span><span class="s">nabla F}_{3} = 0&#39;</span><span class="p">)</span>

<span class="n">xpdf</span><span class="p">(</span><span class="n">crop</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">png</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>Code output</p>
<a class="reference internal image-reference" href="_images/maxwell.png"><img alt="_images/maxwell.png" class="align-center" src="_images/maxwell.png" style="width: 950px;" /></a>
</div>
<div class="section" id="dirac-equation">
<h4>Dirac Equation<a class="headerlink" href="#dirac-equation" title="Permalink to this headline">¶</a></h4>
<p>In <a class="reference internal" href="#doran" id="id15">[Doran]</a> equation 8.89 (page 283) is the geometric algebra formulation of the Dirac equation.  In this equation
<span class="math">\(\psi\)</span> is an 8-component real spinor which is to say that it is a multivector with sacalar, bivector, and
pseudo-vector components in the space-time geometric algebra (it consists only of even grade components).</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span>
<span class="kn">from</span> <span class="nn">printer</span> <span class="kn">import</span> <span class="n">Format</span><span class="p">,</span> <span class="n">xpdf</span>
<span class="kn">from</span> <span class="nn">ga</span> <span class="kn">import</span> <span class="n">Ga</span>

<span class="n">Format</span><span class="p">()</span>

<span class="n">coords</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;t x y z&#39;</span><span class="p">,</span><span class="n">real</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="p">(</span><span class="n">st4d</span><span class="p">,</span><span class="n">g0</span><span class="p">,</span><span class="n">g1</span><span class="p">,</span><span class="n">g2</span><span class="p">,</span><span class="n">g3</span><span class="p">)</span> <span class="o">=</span> <span class="n">Ga</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="s">&#39;gamma*t|x|y|z&#39;</span><span class="p">,</span><span class="n">g</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">coords</span><span class="o">=</span><span class="n">coords</span><span class="p">)</span>
<span class="n">I</span> <span class="o">=</span> <span class="n">st4d</span><span class="o">.</span><span class="n">i</span>

<span class="p">(</span><span class="n">m</span><span class="p">,</span><span class="n">e</span><span class="p">)</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;m e&#39;</span><span class="p">)</span>

<span class="n">psi</span> <span class="o">=</span> <span class="n">st4d</span><span class="o">.</span><span class="n">mv</span><span class="p">(</span><span class="s">&#39;psi&#39;</span><span class="p">,</span><span class="s">&#39;spinor&#39;</span><span class="p">,</span><span class="n">f</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">A</span> <span class="o">=</span> <span class="n">st4d</span><span class="o">.</span><span class="n">mv</span><span class="p">(</span><span class="s">&#39;A&#39;</span><span class="p">,</span><span class="s">&#39;vector&#39;</span><span class="p">,</span><span class="n">f</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">sig_z</span> <span class="o">=</span> <span class="n">g3</span><span class="o">*</span><span class="n">g0</span>

<span class="k">print</span> <span class="s">&#39;</span><span class="se">\\</span><span class="s">text{4-Vector Potential</span><span class="se">\\</span><span class="s">;</span><span class="se">\\</span><span class="s">;}</span><span class="se">\\</span><span class="s">bm{A} =&#39;</span><span class="p">,</span><span class="n">A</span>
<span class="k">print</span> <span class="s">&#39;</span><span class="se">\\</span><span class="s">text{8-component real spinor</span><span class="se">\\</span><span class="s">;</span><span class="se">\\</span><span class="s">;}</span><span class="se">\\</span><span class="s">bm{</span><span class="se">\\</span><span class="s">psi} =&#39;</span><span class="p">,</span><span class="n">psi</span>

<span class="n">dirac_eq</span> <span class="o">=</span> <span class="p">(</span><span class="n">st4d</span><span class="o">.</span><span class="n">grad</span><span class="o">*</span><span class="n">psi</span><span class="p">)</span><span class="o">*</span><span class="n">I</span><span class="o">*</span><span class="n">sig_z</span><span class="o">-</span><span class="n">e</span><span class="o">*</span><span class="n">A</span><span class="o">*</span><span class="n">psi</span><span class="o">-</span><span class="n">m</span><span class="o">*</span><span class="n">psi</span><span class="o">*</span><span class="n">g0</span>
<span class="n">dirac_eq</span> <span class="o">=</span> <span class="n">dirac_eq</span><span class="o">.</span><span class="n">simplify</span><span class="p">()</span>

<span class="n">dirac_eq</span><span class="o">.</span><span class="n">Fmt</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="s">r&#39;%\text{Dirac Equation\;\;}\nabla \bm{\psi} I \sigma_{z}-e\bm{A}\bm{\psi}-m\bm{\psi}\gamma_{t} = 0&#39;</span><span class="p">)</span>

<span class="n">xpdf</span><span class="p">(</span><span class="n">crop</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">png</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
<p>The equations displayed are the partial differential equations for each component of the Dirac equation
in rectangular coordinates we the driver for the equations is the 4-potential <span class="math">\(A\)</span>.  One utility
of these equations is to setup a numerical solver for the Dirac equation.</p>
<a class="reference internal image-reference" href="_images/dirac.png"><img alt="_images/dirac.png" class="align-center" src="_images/dirac.png" style="width: 950px;" /></a>
</div>
<div class="section" id="manifolds-and-tensors">
<h4>Manifolds and Tensors<a class="headerlink" href="#manifolds-and-tensors" title="Permalink to this headline">¶</a></h4>
<p>The example code for tensors on a manifold is</p>
<blockquote>
<div><div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sympy</span> <span class="kn">import</span> <span class="n">symbols</span>
<span class="kn">from</span> <span class="nn">printer</span> <span class="kn">import</span> <span class="n">Format</span><span class="p">,</span> <span class="n">xpdf</span>
<span class="kn">from</span> <span class="nn">ga</span> <span class="kn">import</span> <span class="n">Ga</span>

<span class="n">Format</span><span class="p">()</span>
<span class="n">X</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">(</span><span class="s">&#39;t x y z&#39;</span><span class="p">,</span><span class="n">real</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="p">(</span><span class="n">st4d</span><span class="p">,</span><span class="n">g0</span><span class="p">,</span><span class="n">g1</span><span class="p">,</span><span class="n">g2</span><span class="p">,</span><span class="n">g3</span><span class="p">)</span> <span class="o">=</span> <span class="n">Ga</span><span class="o">.</span><span class="n">build</span><span class="p">(</span><span class="s">&#39;gamma*t|x|y|z&#39;</span><span class="p">,</span><span class="n">g</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">coords</span><span class="o">=</span><span class="n">X</span><span class="p">)</span>

<span class="n">I</span> <span class="o">=</span> <span class="n">st4d</span><span class="o">.</span><span class="n">i</span>

<span class="n">B</span> <span class="o">=</span> <span class="n">st4d</span><span class="o">.</span><span class="n">mv</span><span class="p">(</span><span class="s">&#39;B&#39;</span><span class="p">,</span><span class="s">&#39;vector&#39;</span><span class="p">,</span><span class="n">f</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">E</span> <span class="o">=</span> <span class="n">st4d</span><span class="o">.</span><span class="n">mv</span><span class="p">(</span><span class="s">&#39;E&#39;</span><span class="p">,</span><span class="s">&#39;vector&#39;</span><span class="p">,</span><span class="n">f</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">B</span><span class="o">.</span><span class="n">set_coef</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">E</span><span class="o">.</span><span class="n">set_coef</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">B</span> <span class="o">*=</span> <span class="n">g0</span>
<span class="n">E</span> <span class="o">*=</span> <span class="n">g0</span>
<span class="n">J</span> <span class="o">=</span> <span class="n">st4d</span><span class="o">.</span><span class="n">mv</span><span class="p">(</span><span class="s">&#39;J&#39;</span><span class="p">,</span><span class="s">&#39;vector&#39;</span><span class="p">,</span><span class="n">f</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">F</span> <span class="o">=</span> <span class="n">E</span><span class="o">+</span><span class="n">I</span><span class="o">*</span><span class="n">B</span>

<span class="k">print</span> <span class="s">r&#39;\text{Pseudo Scalar\;\;}I =&#39;</span><span class="p">,</span><span class="n">I</span>
<span class="k">print</span> <span class="s">&#39;</span><span class="se">\\</span><span class="s">text{Magnetic Field Bi-Vector</span><span class="se">\\</span><span class="s">;</span><span class="se">\\</span><span class="s">;} B = </span><span class="se">\\</span><span class="s">bm{B</span><span class="se">\\</span><span class="s">gamma_{t}} =&#39;</span><span class="p">,</span><span class="n">B</span>
<span class="k">print</span> <span class="s">&#39;</span><span class="se">\\</span><span class="s">text{Electric Field Bi-Vector</span><span class="se">\\</span><span class="s">;</span><span class="se">\\</span><span class="s">;} E = </span><span class="se">\\</span><span class="s">bm{E</span><span class="se">\\</span><span class="s">gamma_{t}} =&#39;</span><span class="p">,</span><span class="n">E</span>
<span class="k">print</span> <span class="s">&#39;</span><span class="se">\\</span><span class="s">text{Electromagnetic Field Bi-Vector</span><span class="se">\\</span><span class="s">;</span><span class="se">\\</span><span class="s">;} F = E+IB =&#39;</span><span class="p">,</span><span class="n">F</span>
<span class="k">print</span> <span class="s">&#39;%</span><span class="se">\\</span><span class="s">text{Four Current Density</span><span class="se">\\</span><span class="s">;</span><span class="se">\\</span><span class="s">;} J =&#39;</span><span class="p">,</span><span class="n">J</span>
<span class="n">gradF</span> <span class="o">=</span> <span class="n">st4d</span><span class="o">.</span><span class="n">grad</span><span class="o">*</span><span class="n">F</span>
<span class="k">print</span> <span class="s">&#39;#Geom Derivative of Electomagnetic Field Bi-Vector&#39;</span>
<span class="n">gradF</span><span class="o">.</span><span class="n">Fmt</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="s">&#39;grad*F&#39;</span><span class="p">)</span>

<span class="k">print</span> <span class="s">&#39;#Maxwell Equations&#39;</span>
<span class="k">print</span> <span class="s">&#39;grad*F = J&#39;</span>
<span class="k">print</span> <span class="s">&#39;#Div $E$ and Curl $H$ Equations&#39;</span>
<span class="p">(</span><span class="n">gradF</span><span class="o">.</span><span class="n">get_grade</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="n">J</span><span class="p">)</span><span class="o">.</span><span class="n">Fmt</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="s">&#39;%</span><span class="se">\\</span><span class="s">grade{</span><span class="se">\\</span><span class="s">nabla F}_{1} -J = 0&#39;</span><span class="p">)</span>
<span class="k">print</span> <span class="s">&#39;#Curl $E$ and Div $B$ equations&#39;</span>
<span class="p">(</span><span class="n">gradF</span><span class="o">.</span><span class="n">get_grade</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">Fmt</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="s">&#39;%</span><span class="se">\\</span><span class="s">grade{</span><span class="se">\\</span><span class="s">nabla F}_{3} = 0&#39;</span><span class="p">)</span>

<span class="n">xpdf</span><span class="p">(</span><span class="n">crop</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">png</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
</div>
</div></blockquote>
<p>This code uses a unit sphere as the example manifold and shows the
geometric derivative and directional derivative operators.  Additonally,
rank 1 and rank 2 general tensors are defined.  The rank 2 tensor is
contracted and evaluated to show multilinear properties.  The covariant
derivatives of both tensors are caculated.  The results are</p>
<blockquote>
<div><a class="reference internal image-reference" href="_images/manifold-0.png"><img alt="_images/manifold-0.png" class="align-center" src="_images/manifold-0.png" style="width: 700px;" /></a>
<a class="reference internal image-reference" href="_images/manifold-1.png"><img alt="_images/manifold-1.png" class="align-center" src="_images/manifold-1.png" style="width: 800px;" /></a>
</div></blockquote>
<p class="rubric">Citations</p>
<table class="docutils citation" frame="void" id="doran" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Doran]</td><td><em>(<a class="fn-backref" href="#id2">1</a>, <a class="fn-backref" href="#id3">2</a>, <a class="fn-backref" href="#id4">3</a>, <a class="fn-backref" href="#id5">4</a>, <a class="fn-backref" href="#id13">5</a>, <a class="fn-backref" href="#id14">6</a>, <a class="fn-backref" href="#id15">7</a>)</em> <a class="reference external" href="http://www.mrao.cam.ac.uk/~cjld1/pages/book.htm">http://www.mrao.cam.ac.uk/~cjld1/pages/book.htm</a>
<tt class="docutils literal"><span class="pre">Geometric</span> <span class="pre">Algebra</span> <span class="pre">for</span> <span class="pre">Physicists</span></tt> by C. Doran and A. Lasenby, Cambridge
University Press, 2003.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="hestenes" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Hestenes]</td><td><em>(<a class="fn-backref" href="#id1">1</a>, <a class="fn-backref" href="#id6">2</a>)</em> <a class="reference external" href="http://geocalc.clas.asu.edu/html/CA_to_GC.html">http://geocalc.clas.asu.edu/html/CA_to_GC.html</a>
<tt class="docutils literal"><span class="pre">Clifford</span> <span class="pre">Algebra</span> <span class="pre">to</span> <span class="pre">Geometric</span> <span class="pre">Calculus</span></tt> by D.Hestenes and G. Sobczyk, Kluwer
Academic Publishers, 1984.</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="macdonald" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[Macdonald]</td><td>&#8216;&lt;<a class="reference external" href="http://faculty.luther.edu/~macdonal">http://faculty.luther.edu/~macdonal</a>&gt;&#8217;_
<tt class="docutils literal"><span class="pre">Linear</span> <span class="pre">and</span> <span class="pre">Geometric</span> <span class="pre">Algebra</span></tt> by Alan Macdonald, <a class="reference external" href="http://www.amazon.com/Alan-Macdonald/e/B004MB2QJQ">http://www.amazon.com/Alan-Macdonald/e/B004MB2QJQ</a></td></tr>
</tbody>
</table>
<p class="rubric">Footnotes</p>
<table class="docutils footnote" frame="void" id="f0" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[1]</a></td><td>In this case <span class="math">\(D_{B}^{j_{1}\dots j_{n}} = F\)</span> and <span class="math">\(\partial_{j_{1}\dots j_{n}} = 1\)</span>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="f1" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[2]</a></td><td>Since <span class="math">\(\underline{T}\)</span> is linear we do not require <span class="math">\(I^{2} = \pm 1\)</span>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="f2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[3]</a></td><td>In this case <span class="math">\(y\)</span> is a vector in the tangent space and not a coordinate vector so that the
basis vectors are {em not} a function of <span class="math">\(y\)</span>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="f3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id11">[4]</a></td><td>Preprocessing do not occur for the Ipython notebook and the string post processing commands
<em>%</em> and <em>#</em> are not used in this case</td></tr>
</tbody>
</table>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="GA.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Geometric Algebra</a><ul>
<li><a class="reference internal" href="#what-is-geometric-algebra">What is Geometric Algebra?</a></li>
<li><a class="reference internal" href="#representation-of-multivectors-in-sympy">Representation of Multivectors in <em>sympy</em></a><ul>
<li><a class="reference internal" href="#vector-basis-and-metric">Vector Basis and Metric</a></li>
<li><a class="reference internal" href="#representation-and-reduction-of-multivector-bases">Representation and Reduction of Multivector Bases</a></li>
<li><a class="reference internal" href="#base-representation-of-multivectors">Base Representation of Multivectors</a></li>
<li><a class="reference internal" href="#blade-representation-of-multivectors">Blade Representation of Multivectors</a></li>
</ul>
</li>
<li><a class="reference internal" href="#outer-and-inner-products-left-and-right-contractions">Outer and Inner Products, Left and Right Contractions</a></li>
<li><a class="reference internal" href="#reverse-of-multivector">Reverse of Multivector</a></li>
<li><a class="reference internal" href="#reciprocal-frames">Reciprocal Frames</a></li>
<li><a class="reference internal" href="#manifolds-and-submanifolds">Manifolds and Submanifolds</a></li>
<li><a class="reference internal" href="#geometric-derivative">Geometric Derivative</a><ul>
<li><a class="reference internal" href="#geometric-derivative-on-a-manifold">Geometric Derivative on a Manifold</a><ul>
<li><a class="reference internal" href="#normalizing-basis-for-derivatives">Normalizing Basis for Derivatives</a></li>
<li><a class="reference internal" href="#linear-differential-operators">Linear Differential Operators</a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#linear-transformations">Linear Transformations</a></li>
<li><a class="reference internal" href="#multi-linear-transformations-tensors">Multi-Linear Transformations (Tensors)</a><ul>
<li><a class="reference internal" href="#algebraic-operations">Algebraic Operations</a></li>
<li><a class="reference internal" href="#covariant-contravariant-and-mixed-representations">Covariant, Contravariant, and Mixed Representations</a></li>
<li><a class="reference internal" href="#contraction-and-differentiation">Contraction and Differentiation</a></li>
<li><a class="reference internal" href="#covariant-deriviatives">Covariant Deriviatives</a></li>
</ul>
</li>
<li><a class="reference internal" href="#numpy-latex-and-ansicon-installation">Numpy, LaTeX, and Ansicon Installation</a></li>
<li><a class="reference internal" href="#module-components">Module Components</a><ul>
<li><a class="reference internal" href="#instantiating-a-geometric-algebra">Instantiating a Geometric Algebra</a></li>
<li><a class="reference internal" href="#instantiating-a-multivector">Instantiating a Multivector</a></li>
<li><a class="reference internal" href="#basic-multivector-class-functions">Basic Multivector Class Functions</a></li>
<li><a class="reference internal" href="#basic-multivector-functions">Basic Multivector Functions</a></li>
<li><a class="reference internal" href="#multivector-derivatives">Multivector Derivatives</a></li>
<li><a class="reference internal" href="#submanifolds">Submanifolds</a></li>
<li><a class="reference internal" href="#id10">Linear Transformations</a></li>
<li><a class="reference internal" href="#differential-operators">Differential Operators</a></li>
<li><a class="reference internal" href="#instantiating-a-multi-linear-functions-tensors">Instantiating a Multi-linear Functions (Tensors)</a></li>
<li><a class="reference internal" href="#basic-multilinear-function-class-functions">Basic Multilinear Function Class Functions</a></li>
<li><a class="reference internal" href="#standard-printing">Standard Printing</a></li>
<li><a class="reference internal" href="#latex-printing">Latex Printing</a></li>
</ul>
</li>
<li><a class="reference internal" href="#examples">Examples</a><ul>
<li><a class="reference internal" href="#algebra">Algebra</a><ul>
<li><a class="reference internal" href="#bac-cab-formulas">BAC-CAB Formulas</a></li>
<li><a class="reference internal" href="#reciprocal-frame">Reciprocal Frame</a></li>
<li><a class="reference internal" href="#lorentz-transformation">Lorentz-Transformation</a></li>
<li><a class="reference internal" href="#id12">Linear Transformations</a></li>
</ul>
</li>
<li><a class="reference internal" href="#calculus">Calculus</a><ul>
<li><a class="reference internal" href="#derivatives-in-spherical-coordinates">Derivatives in Spherical Coordinates</a></li>
<li><a class="reference internal" href="#maxwell-s-equations">Maxwell&#8217;s Equations</a></li>
<li><a class="reference internal" href="#dirac-equation">Dirac Equation</a></li>
<li><a class="reference internal" href="#manifolds-and-tensors">Manifolds and Tensors</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/ga.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="GA.html">GA 3.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2014, Alan Bromborsky.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.2.
    </div>
  </body>
</html>